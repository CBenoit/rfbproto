<h1 id="the-rfb-protocol">The RFB Protocol</h1>
<p>This document is based on "The RFB Protocol" by Tristan Richardson of
RealVNC Ltd (formerly of Olivetti Research Ltd / AT&amp;T Labs
Cambridge).</p>
<div class="sectnum">

</div>
<div class="contents">

</div>
<h2 id="introduction">Introduction</h2>
<p>RFB ("remote framebuffer") is a simple protocol for remote access to
graphical user interfaces. Because it works at the framebuffer level it
is applicable to all windowing systems and applications, including X11,
Windows and Macintosh. RFB is the protocol used in VNC (Virtual Network
Computing).</p>
<p>The remote endpoint where the user sits (i.e. the display plus
keyboard and/or pointer) is called the RFB client or viewer. The
endpoint where changes to the framebuffer originate (i.e. the windowing
system and applications) is known as the RFB server.</p>
<p>RFB is truly a "thin client" protocol. The emphasis in the design of
the RFB protocol is to make very few requirements of the client. In this
way, clients can run on the widest range of hardware, and the task of
implementing a client is made as simple as possible.</p>
<p>The protocol also makes the client stateless. If a client disconnects
from a given server and subsequently reconnects to that same server, the
state of the user interface is preserved. Furthermore, a different
client endpoint can be used to connect to the same RFB server. At the
new endpoint, the user will see exactly the same graphical user
interface as at the original endpoint. In effect, the interface to the
user's applications becomes completely mobile. Wherever suitable network
connectivity exists, the user can access their own personal
applications, and the state of these applications is preserved between
accesses from different locations. This provides the user with a
familiar, uniform view of the computing infrastructure wherever they
go.</p>
<h2 id="display-protocol">Display Protocol</h2>
<p>The display side of the protocol is based around a single graphics
primitive: "put a rectangle of pixel data at a given x,y position". At
first glance this might seem an inefficient way of drawing many user
interface components. However, allowing various different encodings for
the pixel data gives us a large degree of flexibility in how to trade
off various parameters such as network bandwidth, client drawing speed
and server processing speed.</p>
<p>A sequence of these rectangles makes a <em>framebuffer update</em>
(or simply <em>update</em>). An update represents a change from one
valid framebuffer state to another, so in some ways is similar to a
frame of video. The rectangles in an update are usually disjoint but
this is not necessarily the case.</p>
<p>The update protocol is demand-driven by the client. That is, an
update is only sent from the server to the client in response to an
explicit request from the client. This gives the protocol an adaptive
quality. The slower the client and the network are, the lower the rate
of updates becomes. With typical applications, changes to the same area
of the framebuffer tend to happen soon after one another. With a slow
client and/or network, transient states of the framebuffer can be
ignored, resulting in less network traffic and less drawing for the
client.</p>
<h3 id="screen-model">Screen Model</h3>
<p>In its simplest form, the RFB protocol uses a single, rectangular
framebuffer. All updates are contained within this buffer and may not
extend outside of it. A client with basic functionality simply presents
this buffer to the user, padding or cropping it as necessary to fit the
user's display.</p>
<p>More advanced RFB clients and servers have the ability to extend this
model and add multiple screens. The purpose being to create a
server-side representation of the client's physical layout. Applications
can use this information to properly position themselves with regard to
screen borders.</p>
<p>In the multiple-screen model, there is still just a single
framebuffer and framebuffer updates are unaffected by the screen layout.
This assures compatibility between basic clients and advanced servers.
Screens are added to this model and act like viewports into the
framebuffer. A basic client acts as if there is a single screen covering
the entire framebuffer.</p>
<p>The server may support up to 255 screens, which must be contained
fully within the current framebuffer. Multiple screens may overlap
partially or completely.</p>
<p>The client must keep track of the contents of the entire framebuffer,
not just the areas currently covered by a screen. Similarly, the server
is free to use encodings that rely on contents currently not visible
inside any screen. For example it may issue a <em>CopyRect</em>
rectangle from any part of the framebuffer that should already be known
to the client.</p>
<p>The client can request changes to the framebuffer size and screen
layout. The server is free to approve or deny these requests at will,
but must always inform the client of the result. See the <a
href="#setdesktopsize">SetDesktopSize</a> message for details.</p>
<p>If the framebuffer size changes, for whatever reason, then all data
in it is invalidated and considered undefined. The server must not use
any encoding that relies on the previous framebuffer contents. Note
however that the semantics for <em>DesktopSize</em> are not well-defined
and do not follow this behaviour in all server implementations. See the
<a href="#desktopsize-pseudo-encoding">DesktopSize Pseudo-encoding</a>
chapter for full details.</p>
<p>Changing only the screen layout does not affect the framebuffer
contents. The client must therefore keep track of the current
framebuffer dimensions and compare it with the one received in the
<em>ExtendedDesktopSize</em> rectangle. Only when they differ may it
discard the framebuffer contents.</p>
<h2 id="input-protocol">Input Protocol</h2>
<p>The input side of the protocol is based on a standard workstation
model of a keyboard and multi-button pointing device. Input events are
simply sent to the server by the client whenever the user presses a key
or pointer button, or whenever the pointing device is moved. These input
events can also be synthesised from other non-standard I/O devices. For
example, a pen-based handwriting recognition engine might generate
keyboard events.</p>
<p>If you have an input source that does not fit this standard
workstation model, the General Input Interface (gii) protocol extension
provides possibilities for input sources with more axes, relative
movement and more buttons.</p>
<h2 id="representation-of-pixel-data">Representation of Pixel Data</h2>
<p>Initial interaction between the RFB client and server involves a
negotiation of the <em>format</em> and <em>encoding</em> with which
pixel data will be sent. This negotiation has been designed to make the
job of the client as easy as possible. The bottom line is that the
server must always be able to supply pixel data in the form the client
wants. However if the client is able to cope equally with several
different formats or encodings, it may choose one which is easier for
the server to produce.</p>
<p>Pixel <em>format</em> refers to the representation of individual
colours by pixel values. The most common pixel formats are 24-bit or
16-bit "true colour", where bit-fields within the pixel value translate
directly to red, green and blue intensities, and 8-bit "colour map"
where an arbitrary mapping can be used to translate from pixel values to
the RGB intensities.</p>
<p><em>Encoding</em> refers to how a rectangle of pixel data will be
sent on the wire. Every rectangle of pixel data is prefixed by a header
giving the X,Y position of the rectangle on the screen, the width and
height of the rectangle, and an <em>encoding type</em> which specifies
the encoding of the pixel data. The data itself then follows using the
specified encoding.</p>
<h2 id="protocol-extensions">Protocol Extensions</h2>
<p>There are a number of ways in which the protocol can be extended:</p>
<dl>
<dt>New encodings</dt>
<dd>
<p>A new encoding type can be added to the protocol relatively easily
whilst maintaining compatibility with existing clients and servers.
Existing servers will simply ignore requests for a new encoding which
they don't support. Existing clients will never request the new encoding
so will never see rectangles encoded that way.</p>
</dd>
<dt>Pseudo encodings</dt>
<dd>
<p>In addition to genuine encodings, a client can request a
"pseudo-encoding" to declare to the server that it supports a certain
extension to the protocol. A server which does not support the extension
will simply ignore the pseudo-encoding. Note that this means the client
must assume that the server does not support the extension until it gets
some extension-specific confirmation from the server. See <a
href="#pseudo-encodings">Pseudo-encodings</a> for a description of
current pseudo-encodings.</p>
</dd>
<dt>New security types</dt>
<dd>
<p>Adding a new security type gives the ultimate flexibility in
modifying the behaviour of the protocol without sacrificing
compatibility with existing clients and servers. A client and server
which agree on a new security type can effectively talk whatever
protocol they like after that, it doesn't necessarily have to be
anything like the RFB protocol.</p>
</dd>
</dl>
<p><strong>Under no circumstances should you use a different protocol
version number</strong>. If you use a different protocol version number
then you are not RFB / VNC compatible.</p>
<p>All three mechanisms for extensions are handled by RealVNC Ltd. To
ensure that you stay compatible with the RFB protocol it is important
that you contact RealVNC Ltd to make sure that your encoding types and
security types do not clash. Please see the RealVNC website at <a
href="http://www.realvnc.com">http://www.realvnc.com</a> for details of
how to contact them.</p>
<h2 id="string-encodings">String Encodings</h2>
<p>The encoding used for strings in the protocol has historically often
been unspecified, or has changed between versions of the protocol. As a
result, there are a lot of implementations which use different,
incompatible encodings. Commonly those encodings have been ISO 8859-1
(also known as Latin-1) or Windows code pages.</p>
<p>It is strongly recommended that new implementations use the UTF-8
encoding for these strings. This allows full unicode support, yet
retains good compatibility with older RFB implementations.</p>
<p>New protocol additions that do not have a legacy problem should
mandate the UTF-8 encoding to provide full character support and to
avoid any issues with ambiguity.</p>
<p>All clients and servers should be prepared to receive invalid UTF-8
sequences at all times. These can occur as a result of historical
ambiguity or because of bugs. Neither case should result in lost
protocol synchronization.</p>
<p>Handling an invalid UTF-8 sequence is largely dependent on the role
that string plays. Modifying the string should only be done when the
string is only used in the user interface. It should be obvious in that
case that the string has been modified, e.g. by appending a notice to
the string.</p>
<h2 id="protocol-messages">Protocol Messages</h2>
<p>The RFB protocol can operate over any reliable transport, either
byte-stream or message-based. Conventionally it is used over a TCP/IP
connection. There are three stages to the protocol. First is the
handshaking phase, the purpose of which is to agree upon the protocol
version and the type of security to be used. The second stage is an
initialisation phase where the client and server exchange
<em>ClientInit</em> and <em>ServerInit</em> messages. The final stage is
the normal protocol interaction. The client can send whichever messages
it wants, and may receive messages from the server as a result. All
these messages begin with a <em>message-type</em> byte, followed by any
message-specific data.</p>
<p>The following descriptions of protocol messages use the basic types
<code>U8</code>, <code>U16</code>, <code>U32</code>, <code>S8</code>,
<code>S16</code>, <code>S32</code>. These represent respectively 8, 16
and 32-bit unsigned integers and 8, 16 and 32-bit signed integers. All
multiple byte integers (other than pixel values themselves) are in big
endian order (most significant byte first).</p>
<p>However, some protocol extensions use protocol messages that have
types that may be in little endian order. These endian agnostic types
are <code>EU16</code>, <code>EU32</code>, <code>ES16</code>,
<code>ES32</code>, with some extension specific indicator of the
endianness.</p>
<p>The type <code>PIXEL</code> is taken to mean a pixel value of
<em>bytesPerPixel</em> bytes, where 8 * <em>bytesPerPixel</em> is the
number of <em>bits-per-pixel</em> as agreed by the client and server,
either in the <em>ServerInit</em> message (<a
href="#serverinit">ServerInit</a>) or a <em>SetPixelFormat</em> message
(<a href="#setpixelformat">SetPixelFormat</a>).</p>
<h3 id="handshaking-messages">Handshaking Messages</h3>
<h4 id="protocolversion">ProtocolVersion</h4>
<p>Handshaking begins by the server sending the client a
<em>ProtocolVersion</em> message. This lets the client know which is the
highest RFB protocol version number supported by the server. The client
then replies with a similar message giving the version number of the
protocol which should actually be used (which may be different to that
quoted by the server). A client should never request a protocol version
higher than that offered by the server. It is intended that both clients
and servers may provide some level of backwards compatibility by this
mechanism.</p>
<p>The only published protocol versions at this time are 3.3, 3.7, 3.8
(version 3.5 was wrongly reported by some clients, but this should be
interpreted by all servers as 3.3). Addition of a new encoding or
pseudo-encoding type does not require a change in protocol version,
since a server can simply ignore encodings it does not understand.</p>
<p>The <em>ProtocolVersion</em> message consists of 12 bytes interpreted
as a string of ASCII characters in the format
"<code>RFB xxx.yyy\n</code>" where <code>xxx</code> and <code>yyy</code>
are the major and minor version numbers, padded with zeros.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>12</p></td>
<td><p>"<code>RFB 003.003\n</code>" (hex 52 46 42 20 30 30 33 2e 30 30
33 0a)</p></td>
</tr>
</tbody>
</table>
<p>or</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>12</p></td>
<td><p>"<code>RFB 003.007\n</code>" (hex 52 46 42 20 30 30 33 2e 30 30
37 0a)</p></td>
</tr>
</tbody>
</table>
<p>or</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>12</p></td>
<td><p>"<code>RFB 003.008\n</code>" (hex 52 46 42 20 30 30 33 2e 30 30
38 0a)</p></td>
</tr>
</tbody>
</table>
<h4 id="security">Security</h4>
<p>Once the protocol version has been decided, the server and client
must agree on the type of security to be used on the connection.</p>
<dl>
<dt>Version 3.7 onwards</dt>
<dd>
<p>The server lists the security types which it supports:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>number-of-security-types</em></td>
</tr>
<tr class="even">
<td><em>number-of-security-types</em></td>
<td><code>U8</code> array</td>
<td><em>security-types</em></td>
</tr>
</tbody>
</table>
<p>If the server listed at least one valid security type supported by
the client, the client sends back a single byte indicating which
security type is to be used on the connection:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>security-type</em></td>
</tr>
</tbody>
</table>
<p>If <em>number-of-security-types</em> is zero, then for some reason
the connection failed (e.g. the server cannot support the desired
protocol version). This is followed by a string describing the reason
(where a string is specified as a length followed by that many ASCII
characters):</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>reason-length</em></td>
</tr>
<tr class="even">
<td><em>reason-length</em></td>
<td><code>U8</code> array</td>
<td><em>reason-string</em></td>
</tr>
</tbody>
</table>
<p>The server closes the connection after sending the
<em>reason-string</em>.</p>
</dd>
<dt>Version 3.3</dt>
<dd>
<p>The server decides the security type and sends a single word:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>security-type</em></td>
</tr>
</tbody>
</table>
<p>The <em>security-type</em> may only take the value 0, 1 or 2. A value
of 0 means that the connection has failed and is followed by a string
giving the reason, as described above.</p>
</dd>
</dl>
<p>The security types defined in this document are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Invalid</td>
</tr>
<tr class="even">
<td>1</td>
<td><a href="#none">None</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td><a href="#vnc-authentication">VNC Authentication</a></td>
</tr>
<tr class="even">
<td>5</td>
<td><a href="#rsa-aes-security-type">RSA-AES Security Type</a></td>
</tr>
<tr class="odd">
<td>6</td>
<td><a href="#rsa-aes-unencrypted-security-type">RSA-AES Unencrypted
Security Type</a></td>
</tr>
<tr class="even">
<td>13</td>
<td><a href="#rsa-aes-two-step-security-type">RSA-AES Two-step Security
Type</a></td>
</tr>
<tr class="odd">
<td>16</td>
<td><a href="#tight-security-type">Tight Security Type</a></td>
</tr>
<tr class="even">
<td>19</td>
<td><a href="#vencrypt">VeNCrypt</a></td>
</tr>
<tr class="odd">
<td>22</td>
<td><a href="#xvp-authentication">xvp Authentication</a></td>
</tr>
<tr class="even">
<td>30</td>
<td><a href="#diffie-hellman-authentication">Diffie-Hellman
Authentication</a></td>
</tr>
<tr class="odd">
<td>113</td>
<td><a href="#mslogonii-authentication">MSLogonII
Authentication</a></td>
</tr>
<tr class="even">
<td>129</td>
<td><a href="#rsa-aes-256-security-type">RSA-AES-256 Security
Type</a></td>
</tr>
<tr class="odd">
<td>130</td>
<td><a href="#rsa-aes-256-unencrypted-security-type">RSA-AES-256
Unencrypted Security Type</a></td>
</tr>
<tr class="even">
<td>133</td>
<td><a href="#rsa-aes-256-two-step-security-type">RSA-AES-256 Two-step
Security Type</a></td>
</tr>
</tbody>
</table>
<p>Other registered security types are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3-4</td>
<td>RealVNC</td>
</tr>
<tr class="even">
<td>7-12</td>
<td>RealVNC</td>
</tr>
<tr class="odd">
<td>14-15</td>
<td>RealVNC</td>
</tr>
<tr class="even">
<td>17</td>
<td>Ultra</td>
</tr>
<tr class="odd">
<td>18</td>
<td>TLS</td>
</tr>
<tr class="even">
<td>20</td>
<td>SASL</td>
</tr>
<tr class="odd">
<td>21</td>
<td>MD5 hash authentication</td>
</tr>
<tr class="even">
<td>23</td>
<td>Secure Tunnel</td>
</tr>
<tr class="odd">
<td>24</td>
<td>Integrated SSH</td>
</tr>
<tr class="even">
<td>31-35</td>
<td>Apple Inc.</td>
</tr>
<tr class="odd">
<td>128</td>
<td>RealVNC</td>
</tr>
<tr class="even">
<td>131-132</td>
<td>RealVNC</td>
</tr>
<tr class="odd">
<td>134-255</td>
<td>RealVNC</td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA<a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>Once the <em>security-type</em> has been decided, data specific to
that <em>security-type</em> follows (see <a
href="#security-types">Security Types</a> for details). At the end of
the security handshaking phase, the protocol normally continues with the
<em>SecurityResult</em> message.</p>
<p>Note that after the security handshaking phase, it is possible that
further protocol data is over an encrypted or otherwise altered
channel.</p>
<h4 id="securityresult">SecurityResult</h4>
<p>The server sends a word to inform the client whether the security
handshaking was successful.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><h5 id="section">4</h5></td>
<td><p><code>U32</code></p></td>
<td><p>0 1 2</p></td>
<td><p>status: OK failed failed, too many attempts<a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p></td>
</tr>
</tbody>
</table>
<p>If successful, the protocol passes to the initialisation phase (<a
href="#initialisation-messages">Initialisation Messages</a>).</p>
<dl>
<dt>Version 3.8 onwards</dt>
<dd>
<p>If unsuccessful, the server sends a string describing the reason for
the failure, and then closes the connection:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>reason-length</em></td>
</tr>
<tr class="even">
<td><em>reason-length</em></td>
<td><code>U8</code> array</td>
<td><em>reason-string</em></td>
</tr>
</tbody>
</table>
</dd>
<dt>Version 3.3 and 3.7</dt>
<dd>
<p>If unsuccessful, the server closes the connection.</p>
</dd>
</dl>
<h3 id="security-types">Security Types</h3>
<h4 id="none">None</h4>
<p>No authentication is needed and protocol data is to be sent
unencrypted.</p>
<dl>
<dt>Version 3.8 onwards</dt>
<dd>
<p>The protocol continues with the <em>SecurityResult</em> message.</p>
</dd>
<dt>Version 3.3 and 3.7</dt>
<dd>
<p>The protocol passes to the initialisation phase (<a
href="#initialisation-messages">Initialisation Messages</a>).</p>
</dd>
</dl>
<h4 id="vnc-authentication">VNC Authentication</h4>
<p>VNC authentication is to be used and protocol data is to be sent
unencrypted. The server sends a random 16-byte challenge:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td><code>U8</code></td>
<td><em>challenge</em></td>
</tr>
</tbody>
</table>
<p>The client encrypts the challenge with DES, using a password supplied
by the user as the key. A password longer than the 64 bits required by
DES is simply truncated. If the password is shorter than required then
the key shall be padded with zeroes.</p>
<p>Note: The lowest bit of each byte is considered the first bit and the
highest discarded as parity. This is the reverse order of most
implementations of DES so the key may require adjustment to give the
expected result.</p>
<p>Each 8 bytes of the challenge is encrypted independently (i.e. ECB
mode) and sent back to the server:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td><code>U8</code></td>
<td><em>response</em></td>
</tr>
</tbody>
</table>
<p>The protocol continues with the <em>SecurityResult</em> message.</p>
<h4 id="tight-security-type">Tight Security Type</h4>
<p>The Tight security type is a generic protocol extension that allows
for three things:</p>
<dl>
<dt>Tunneling of data</dt>
<dd>
<p>A tunnel can be e.g. encryption, or indeed a no-op tunnel.</p>
</dd>
<dt>Authentication</dt>
<dd>
<p>The Tight security type allows for flexible authentication of the
client, which is typically one of the other security types.</p>
</dd>
<dt>Server capabilities</dt>
<dd>
<p>As a last step the Tight security type extends the <a
href="#serverinit">ServerInit</a> message and enables the server to let
the client know about the server capabilities in terms of encodings and
supported message types.</p>
</dd>
</dl>
<p>The Tight security type is under the control of the TightVNC project,
and any new numbers must be registered with that project before they can
be added to any of the lists of Tight capabilities. It is strongly
recommended that any messages and security types registered with RealVNC
are also registered with the TightVNC project (register security types
as Tight authentication capabilities) in order to eliminate clashes as
much as is possible. Same thing with new encodings, but in that case the
problem is not as severe as the TightVNC project are not using any
encodings that are not registered with RealVNC. Please see the TightVNC
website at <a
href="http://www.tightvnc.com/">http://www.tightvnc.com/</a> for details
on how to contact the project.</p>
<p>After the Tight security type has been selected, the server starts by
sending a list of supported tunnels, in order of preference:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>number-of-tunnels</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-tunnels</em> repetitions of the
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td><code>CAPABILITY</code></td>
<td><em>tunnel</em></td>
</tr>
</tbody>
</table>
<p>where <code>CAPABILITY</code> is</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>S32</code></td>
<td><em>code</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U8</code> array</td>
<td><em>vendor</em></td>
</tr>
<tr class="odd">
<td>8</td>
<td><code>U8</code> array</td>
<td><em>signature</em></td>
</tr>
</tbody>
</table>
<p>Note that the <em>code</em> is not the only thing identifying a
capability. The client must ensure that all members of the structure
match before using the capability. Also note that <em>code</em> is
<code>U32</code> in the original Tight documentation and implementation,
but since <em>code</em> is used to hold encoding numbers we have
selected <code>S32</code> in this document.</p>
<p>The following tunnel capabilities are registered:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Vendor</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>NOTUNNEL</code>"</td>
<td>No tunneling</td>
</tr>
</tbody>
</table>
<p>If <em>number-of-tunnels</em> is non-zero, the client has to request
a tunnel from the list with a tunneling method request:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>S32</code></td>
<td><em>code</em></td>
</tr>
</tbody>
</table>
<p>If <em>number-of-tunnels</em> is zero, the client must make no such
request, instead the server carries on with sending the list of
supported authentication types, in order of preference:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>number-of-auth-types</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-auth-types</em> repetitions of the
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td><code>CAPABILITY</code></td>
<td><em>auth-type</em></td>
</tr>
</tbody>
</table>
<p>The following authentication capabilities are registered:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Vendor</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>"<code>STDV</code>"</td>
<td>"<code>NOAUTH__</code>"</td>
<td><a href="#none">None</a></td>
</tr>
<tr class="even">
<td>2</td>
<td>"<code>STDV</code>"</td>
<td>"<code>VNCAUTH_</code>"</td>
<td><a href="#vnc-authentication">VNC Authentication</a></td>
</tr>
<tr class="odd">
<td>19</td>
<td>"<code>VENC</code>"</td>
<td>"<code>VENCRYPT</code>"</td>
<td><a href="#vencrypt">VeNCrypt</a></td>
</tr>
<tr class="even">
<td><p>20</p></td>
<td><p>"<code>GTKV</code>"</p></td>
<td><p>"<code>SASL____</code>"</p></td>
<td><p>Simple Authentication and Security Layer (SASL)</p></td>
</tr>
<tr class="odd">
<td>129</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>ULGNAUTH</code>"</td>
<td><a href="#tight-unix-login-authentication">Tight Unix Login
Authentication</a></td>
</tr>
<tr class="even">
<td>130</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>XTRNAUTH</code>"</td>
<td>External Authentication</td>
</tr>
</tbody>
</table>
<p>Note that the codes used here are independent from the standard
security types and cannot be used interchangeably.</p>
<p>If <em>number-of-auth-types</em> is non-zero, the client has to
request an authentication type from the list with an authentication
scheme request:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>S32</code></td>
<td><em>code</em></td>
</tr>
</tbody>
</table>
<p>For <em>code</em> 1, the protocol the proceeds at security type <a
href="#none">None</a> and for <em>code</em> 2 it proceeds at security
type <a href="#vnc-authentication">VNC Authentication</a>.</p>
<p>If <em>number-of-auth-types</em> is zero, the protocol the proceeds
directly at security type <a href="#none">None</a>.</p>
<p>Note that the <a href="#serverinit">ServerInit</a> message is
extended when the Tight security type has been activated.</p>
<h6 id="tight-unix-login-authentication">Tight Unix Login
Authentication</h6>
<p>Tight Unix Login Authentication is to be used and the client sends a
username and password in the following form:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>username-length</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U32</code></td>
<td><em>password-length</em></td>
</tr>
<tr class="odd">
<td><em>username-length</em></td>
<td><code>U8</code> array</td>
<td><em>username</em></td>
</tr>
<tr class="even">
<td><em>password-length</em></td>
<td><code>U8</code> array</td>
<td><em>password</em></td>
</tr>
</tbody>
</table>
<p>The text encoding used for username and password are historically
undefined but it is strongly recommended to use UTF-8 (see <a
href="#string-encodings">String Encodings</a> for more details).</p>
<p>After receiving the credentials, the server verifies if they are
correct and continues with the <a
href="#securityresult">SecurityResult</a> message.</p>
<h4 id="vencrypt">VeNCrypt</h4>
<p>The VeNCrypt security type is a generic authentication method which
encapsulates multiple authentication subtypes.</p>
<p>After VeNCrypt security type is selected server sends the highest
version of VeNCrypt it can support. Although two versions exist, 0.1 and
0.2, this document describes only newer version 0.2.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>0</td>
<td>Major version number</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>2</td>
<td>Minor version number</td>
</tr>
</tbody>
</table>
<p>Then client sends back the highest VeNCrypt version it can support,
up to version that it received from the server.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>Major version number</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>Minor version number</td>
</tr>
</tbody>
</table>
<p>After that server sends one byte response which indicates if
everything is OK. Non-zero value means failure and connection will be
closed. Zero value means success.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>Ack</td>
</tr>
</tbody>
</table>
<p>Then server sends list of supported VeNCrypt subtypes.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>subtypes length</td>
</tr>
<tr class="even">
<td>subtypes length</td>
<td><code>U32</code> array</td>
<td>subtypes</td>
</tr>
</tbody>
</table>
<p>Following VeNCrypt subtypes are defined in this document:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>256</td>
<td>Plain</td>
<td>Plain authentication (should be never used)</td>
</tr>
<tr class="even">
<td>257</td>
<td>TLSNone</td>
<td>TLS encryption with no authentication</td>
</tr>
<tr class="odd">
<td>258</td>
<td>TLSVnc</td>
<td>TLS encryption with VNC authentication</td>
</tr>
<tr class="even">
<td>259</td>
<td>TLSPlain</td>
<td>TLS encryption with Plain authentication</td>
</tr>
<tr class="odd">
<td>260</td>
<td>X509None</td>
<td>X509 encryption with no authentication</td>
</tr>
<tr class="even">
<td>261</td>
<td>X509Vnc</td>
<td>X509 encryption with VNC authentication</td>
</tr>
<tr class="odd">
<td>262</td>
<td>X509Plain</td>
<td>X509 encryption with Plain authentication</td>
</tr>
<tr class="even">
<td>263</td>
<td>TLSSASL</td>
<td>TLS encryption with SASL authentication</td>
</tr>
<tr class="odd">
<td>264</td>
<td>X509SASL</td>
<td>X509 encryption with SASL authentication</td>
</tr>
</tbody>
</table>
<p>In addition, any of the normal VNC security types (except VeNCrypt)
may be sent.</p>
<p>After that client selects one VeNCrypt subtype and sends back the
number of that type.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U32</code></td>
<td>Selected VeNCrypt subtype</td>
</tr>
</tbody>
</table>
<p>If client supports none of the VeNCrypt subtypes it terminates
connection.</p>
<p>For TLS and X509 subtypes, the server then sends a one byte response
which indicates if everything is OK. Non-one value means failure and
connection will be closed. One value means success.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>Ack</td>
</tr>
</tbody>
</table>
<p>When subtype is selected authentication continues as written in
particular VeNCrypt subtype description.</p>
<h6 id="subtypes-with-tls-or-x509-prefix">Subtypes with TLS or X509
prefix</h6>
<p>All those subtypes use TLS-encrypted stream and server use anonymous
X509 certificate (subtypes with the TLS prefix) or valid X509
certificate (subtypes with the X509 prefix). When session is negotiated,
all further traffic is send via this encrypted channel.</p>
<p>After receiving the U32 confirmation of the VeNCrypt subtype, the TLS
handshake is performed between the client and server. If the handshake
is unsuccessful the connection must be closed and no further RFB
protocol messages attempted.</p>
<p>Note about TLS parameters, like algorithm and key length. VeNCrypt
doesn't enforce any restriction, setting should be determined by local
security policy on client, respective server, side. This also applies
for validity of the server certificate, client side can decide if it
wants to accept invalid server certificate.</p>
<p>In case TLS handshake is not successful, detailed information of
failure can be obtained from underlying TLS stream and both sides must
close the connection.</p>
<p>In case TLS handshake is successful and TLS channel is estabilished,
VeNCrypt authentication can continue.</p>
<h6 id="subtypes-with-none-suffix">Subtypes with None suffix</h6>
<p>After TLS handshake, authentication is successful and both sides can
continue with the <a href="#securityresult">SecurityResult</a>
message.</p>
<h6 id="subtypes-with-vnc-suffix">Subtypes with Vnc suffix</h6>
<p>Authentication continues with the <a href="#vnc-authentication">VNC
Authentication</a> method when TLS handshake is completed.</p>
<h6 id="plain-subtype">Plain subtype</h6>
<p>Client sends the username and password in the following form:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>username-length</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U32</code></td>
<td><em>password-length</em></td>
</tr>
<tr class="odd">
<td><em>username-length</em></td>
<td><code>U8</code> array</td>
<td><em>username</em></td>
</tr>
<tr class="even">
<td><em>password-length</em></td>
<td><code>U8</code> array</td>
<td><em>password</em></td>
</tr>
</tbody>
</table>
<p>After that server verifies if supplied credentials are correct and
continues with the <a href="#securityresult">SecurityResult</a>
message.</p>
<h6 id="subtypes-with-plain-suffix">Subtypes with Plain suffix</h6>
<p>Authentication continues with the <a href="#plain-subtype">Plain
subtype</a> method when TLS handshake is completed.</p>
<h6 id="subtypes-with-sasl-suffix">Subtypes with SASL suffix</h6>
<p>Authentication continues with the SASL method when TLS handshake is
completed.</p>
<h4 id="rsa-aes-security-type">RSA-AES Security Type</h4>
<p>After this security type is selected, the server sends its RSA public
key. The public key, i.e., the modulus and the public exponent, are
big-endian unsigned integers. If the key length is too small or too big,
the client will disconnect.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>server-key-length</em></td>
</tr>
<tr class="even">
<td><em>ceil(server-key-length / 8)</em></td>
<td><code>U8</code> array</td>
<td>modulus</td>
</tr>
<tr class="odd">
<td><em>ceil(server-key-length / 8)</em></td>
<td><code>U8</code> array</td>
<td>public exponent</td>
</tr>
</tbody>
</table>
<p>The client should verify the server's public key to ensure that it is
trustworthy. Then the client also sends its public key.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>client-key-length</em></td>
</tr>
<tr class="even">
<td><em>ceil(client-key-length / 8)</em></td>
<td><code>U8</code> array</td>
<td>modulus</td>
</tr>
<tr class="odd">
<td><em>ceil(client-key-length / 8)</em></td>
<td><code>U8</code> array</td>
<td>public exponent</td>
</tr>
</tbody>
</table>
<p>Note that <em>client-key-length</em> can be different from
<em>server-key-length</em>.</p>
<p>If the key length is too small or too big, the server will
disconnect.</p>
<p>The server generates a random number of 16 bytes and encrypts it with
the client's public key. The EME-PKCS1-v1_5 padding algorithm is used.
Then the server sends the encrypted random number.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>length</em></td>
</tr>
<tr class="even">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td>encrypted random number</td>
</tr>
</tbody>
</table>
<p>The <em>length</em> of the encrypted random number equals to
<em>ceil(client-key-length / 8)</em>.</p>
<p>The client also generates a random number of 16 bytes, encrypts it
with the server's public key and then sends it.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>length</em></td>
</tr>
<tr class="even">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td>encrypted random number</td>
</tr>
</tbody>
</table>
<p>The <em>length</em> of the encrypted random number equals to
<em>ceil(server-key-length / 8)</em>.</p>
<p>The server's random number is decrypted with the client's private
key. At the same time, the client's random number is decrypted with the
server's private key. Now both random numbers are known by both sides.
The client session key and server session key can be derived as
follows:</p>
<pre><code>ClientSessionKey = the first 16 bytes of SHA1(ServerRandom || ClientRandom)
ServerSessionKey = the first 16 bytes of SHA1(ClientRandom || ServerRandom)</code></pre>
<p>where <code>||</code> means concatenation.</p>
<p>The client session key is used to encrypted the messages from the
client to the server. The server session key is used to encrypted the
messages from the server to the client.</p>
<p>After that, all the messages will be encrypted with the AES-EAX mode,
which involves AES-CTR and CMAC. For each message, there is a message
header of a 2-byte big-endian integer, which stands for the length of
the message and is also the associated data of the AES-EAX mode. Also, a
16-byte little-endian message index increments from zero as the nonce of
the AES-EAX mode. The size of MAC is 16 bytes. An encrypted message
looks like:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>message-length</em></td>
</tr>
<tr class="even">
<td><em>message-length</em></td>
<td><code>U8</code> array</td>
<td>encrypted message</td>
</tr>
<tr class="odd">
<td>16</td>
<td><code>U8</code> array</td>
<td>MAC generated by the AES-EAX mode</td>
</tr>
</tbody>
</table>
<p>The server computes and sends the encrypted server hash:</p>
<pre><code>ServerHash = SHA1(ServerPublicKey || ClientPublicKey)</code></pre>
<p>Note that <em>ServerPublicKey</em> is of <em>ceil(server-key-length /
8)</em> 2 + 4* bytes and <em>ClientPublicKey</em> is of
<em>ceil(client-key-length / 8)</em> 2 + 4* bytes.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>2 20 16</p></td>
<td><p><code>U16</code> <code>U8</code> array <code>U8</code>
array</p></td>
<td><p>20</p></td>
<td><p>length of the server hash encrypted server hash MAC</p></td>
</tr>
</tbody>
</table>
<p>The client computes and sends the encrypted client hash:</p>
<pre><code>ClientHash = SHA1(ClientPublicKey || ServerPublicKey)</code></pre>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>2 20 16</p></td>
<td><p><code>U16</code> <code>U8</code> array <code>U8</code>
array</p></td>
<td><p>20</p></td>
<td><p>length of the client hash encrypted client hash MAC</p></td>
</tr>
</tbody>
</table>
<p>After decrypting the client hash, the server should compare the
received client hash with the one it computes itself. Vice versa.</p>
<p>The server sends the subtype to let client know what credentials are
needed.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>2 1 16</p></td>
<td><p><code>U16</code> <code>U8</code> array <code>U8</code>
array</p></td>
<td><p>1</p></td>
<td><p>length of subtype encrypted subtype MAC</p></td>
</tr>
</tbody>
</table>
<p>If the subtype is 1, both username and password are needed. If the
subtype is 2, only password is needed. Other values are invalid.</p>
<p>The client sends the login credentials.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>length-crendentials</em></td>
</tr>
<tr class="even">
<td><em>length-crendentials</em></td>
<td><code>U8</code> array</td>
<td>encrypted crendentials</td>
</tr>
<tr class="odd">
<td>16</td>
<td><code>U8</code> array</td>
<td>MAC</td>
</tr>
</tbody>
</table>
<p>The plaintext message of the credentials is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>length-username</em> (is 0 if subtype=2)</td>
</tr>
<tr class="even">
<td><em>length-username</em></td>
<td><code>U8</code> array</td>
<td>username (can be empty)</td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>length-password</em></td>
</tr>
<tr class="even">
<td><em>length-password</em></td>
<td><code>U8</code> array</td>
<td>password</td>
</tr>
</tbody>
</table>
<p>The username and password should be UTF-8 encoded.</p>
<p>After that the server continues with the encrypted SecurityResult
message.</p>
<p>Note that an RA2 encrypted message is not necessarily a single RFB
message, vice versa. That is to say the RA2 encryption layer is an
independent layer between the TCP layer and the RFB layer, which is
similar to the function of TLS.</p>
<h4 id="rsa-aes-unencrypted-security-type">RSA-AES Unencrypted Security
Type</h4>
<p>The RA2ne security type is identical to the RA2 security type
(RSA-AES Security Type), except that only the security handshake is
encrypted. The SecurityResult message and all following data remains
unencrypted.</p>
<h4 id="rsa-aes-two-step-security-type">RSA-AES Two-step Security
Type</h4>
<p>The RA2r security type is identical to the RA2 security type (RSA-AES
Security Type) , except that after the server receives the credentials
the server and client will have another round of key derivation by
sending two new random numbers and generate a new pair of session keys
for the following encryption. Different from the first round, the random
numbers are encrypted by AES-EAX instead of by RSA. Also, the 16-byte
message index will be reset to zero.</p>
<h4 id="rsa-aes-256-security-type">RSA-AES-256 Security Type</h4>
<p>The RA2_256 security type is identical to the RA2 security type
(RSA-AES Security Type), except that:</p>
<pre><code>ClientSessionKey = SHA256(ServerRandom || ClientRandom)
ServerSessionKey = SHA256(ClientRandom || ServerRandom)
ServerHash = SHA256(ServerPublicKey || ClientPublicKey)
ClientHash = SHA256(ClientPublicKey || ServerPublicKey)</code></pre>
<h4 id="rsa-aes-256-unencrypted-security-type">RSA-AES-256 Unencrypted
Security Type</h4>
<p>The RA2ne_256 security type is identical to the RA2ne security type
(RSA-AES Unencrypted Security Type), except that:</p>
<pre><code>ClientSessionKey = SHA256(ServerRandom || ClientRandom)
ServerSessionKey = SHA256(ClientRandom || ServerRandom)
ServerHash = SHA256(ServerPublicKey || ClientPublicKey)
ClientHash = SHA256(ClientPublicKey || ServerPublicKey)</code></pre>
<h4 id="rsa-aes-256-two-step-security-type">RSA-AES-256 Two-step
Security Type</h4>
<p>The RA2r_256 security type is identical to the RA2r security type
(RSA-AES Two-step Security Type), except that:</p>
<pre><code>ClientSessionKey = SHA256(ServerRandom || ClientRandom)
ServerSessionKey = SHA256(ClientRandom || ServerRandom)
ServerHash = SHA256(ServerPublicKey || ClientPublicKey)
ClientHash = SHA256(ClientPublicKey || ServerPublicKey)</code></pre>
<h4 id="xvp-authentication">xvp Authentication</h4>
<p>The xvp security type extends the standard <a
href="#vnc-authentication">VNC Authentication</a> with a username and a
target system that the client wishes to connect to.</p>
<p>After the xvp security type is selected the server sends out the
username and the target system name:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>username-length</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>target-length</em></td>
</tr>
<tr class="odd">
<td><em>username-length</em></td>
<td><code>U8</code> array</td>
<td><em>username</em></td>
</tr>
<tr class="even">
<td><em>target-length</em></td>
<td><code>U8</code> array</td>
<td><em>target</em></td>
</tr>
</tbody>
</table>
<p>Both <em>username</em> and <em>target</em> should be encoded using
UTF-8.</p>
<p>After that the communication continues as if <a
href="#vnc-authentication">VNC Authentication</a> had been selected.</p>
<h4 id="diffie-hellman-authentication">Diffie-Hellman
Authentication</h4>
<p>The Diffie-Hellman security type allows authentication using a
username and password with protection from eavesdropping.</p>
<p>After the Diffie-Hellman security type is selected the server sends
over a set of Diffie-Hellman parameters:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>generator</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>key-size</em></td>
</tr>
<tr class="odd">
<td><em>key-size</em></td>
<td><code>U8</code> array</td>
<td><em>prime-modulus</em></td>
</tr>
<tr class="even">
<td><em>key-size</em></td>
<td><code>U8</code> array</td>
<td><em>public-value</em></td>
</tr>
</tbody>
</table>
<p>The client can then generate a shared secret from these values using
the Diffie-Hellman algorithm. An AES encryption key is then derived from
this shared secret by generating a MD5 digest of the shared secret.</p>
<p>The client should encrypt the username and password using AES in ECB
mode. Both fields should be encoded using UTF-8, NULL terminated and
padded with random data so the length of each is 64 bytes. I.e. the
total plain text message should be 128 bytes.</p>
<p>The client then sends the encrypted data, and it's public value to
the server as such:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>128</td>
<td><code>U8</code> array</td>
<td><em>encrypted-credentials</em></td>
</tr>
<tr class="even">
<td><em>key-size</em></td>
<td><code>U8</code> array</td>
<td><em>public-value</em></td>
</tr>
</tbody>
</table>
<p>After that the server verifies if supplied credentials are correct
and continues with the <a href="#securityresult">SecurityResult</a>
message.</p>
<h4 id="mslogonii-authentication">MSLogonII Authentication</h4>
<p>The MSLogonII security type allows authentication using username and
password. It also uses Diffie-Hellman key exchange. However, the key
size is fixed at 64 bit, which can be cracked by modern computers
immediately, so it should not be used to prevent eavesdropping.</p>
<p>After the MSLogonII security type is selected the server sends the
following Diffie-Hellman parameters:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8</td>
<td><code>U8</code> array</td>
<td><em>generator</em></td>
</tr>
<tr class="even">
<td>8</td>
<td><code>U8</code> array</td>
<td><em>modulus</em></td>
</tr>
<tr class="odd">
<td>8</td>
<td><code>U8</code> array</td>
<td><em>public-value</em></td>
</tr>
</tbody>
</table>
<p>The client can then generate a shared secret from these values using
the Diffie-Hellman algorithm. The client then uses the shared secret as
the key for DES encryption.</p>
<p>The client should encrypt the username and password using DES in CBC
mode, respectively. Both fields should be encoded using UTF-8, NULL
terminated and padded with random data so the length of each is 256 and
64 bytes respectively. The DES algorithm used here is the same as the
one for VNC authentication, which uses the reverse bit order compared
with most implementations. The shared secret is also used as the IV.</p>
<p>The client then sends the encrypted data, and its public value to the
server.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8</td>
<td><code>U8</code> array</td>
<td><em>public-value</em></td>
</tr>
<tr class="even">
<td>256</td>
<td><code>U8</code> array</td>
<td><em>encrypted-username</em></td>
</tr>
<tr class="odd">
<td>64</td>
<td><code>U8</code> array</td>
<td><em>encrypted-password</em></td>
</tr>
</tbody>
</table>
<h3 id="initialisation-messages">Initialisation Messages</h3>
<p>Once the client and server are sure that they're happy to talk to one
another using the agreed security type, the protocol passes to the
initialisation phase. The client sends a <em>ClientInit</em> message
followed by the server sending a <em>ServerInit</em> message.</p>
<h4 id="clientinit">ClientInit</h4>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>shared-flag</em></td>
</tr>
</tbody>
</table>
<p><em>Shared-flag</em> is non-zero (true) if the server should try to
share the desktop by leaving other clients connected, zero (false) if it
should give exclusive access to this client by disconnecting all other
clients.</p>
<h4 id="serverinit">ServerInit</h4>
<p>After receiving the <em>ClientInit</em> message, the server sends a
<em>ServerInit</em> message. This tells the client the width and height
of the server's framebuffer, its pixel format and the name associated
with the desktop:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>framebuffer-width</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>framebuffer-height</em></td>
</tr>
<tr class="odd">
<td>16</td>
<td><code>PIXEL_FORMAT</code></td>
<td><em>server-pixel-format</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U32</code></td>
<td><em>name-length</em></td>
</tr>
<tr class="odd">
<td><em>name-length</em></td>
<td><code>U8</code> array</td>
<td><em>name-string</em></td>
</tr>
</tbody>
</table>
<p>The text encoding used for <em>name-string</em> is historically
undefined but it is strongly recommended to use UTF-8 (see <a
href="#string-encodings">String Encodings</a> for more details).</p>
<p><code>PIXEL_FORMAT</code> is defined as:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>bits-per-pixel</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>depth</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>big-endian-flag</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>true-colour-flag</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>red-max</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>green-max</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>blue-max</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>red-shift</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>green-shift</em></td>
</tr>
<tr class="even">
<td><p>1 3</p></td>
<td><p><code>U8</code></p></td>
<td><p><em>blue-shift</em> <em>padding</em></p></td>
</tr>
</tbody>
</table>
<p><em>Server-pixel-format</em> specifies the server's natural pixel
format. This pixel format will be used unless the client requests a
different format using the <em>SetPixelFormat</em> message (<a
href="#setpixelformat">SetPixelFormat</a>).</p>
<p><em>Bits-per-pixel</em> is the number of bits used for each pixel
value on the wire. This must be greater than or equal to <em>depth</em>,
which is the number of useful bits in the pixel value. Currently
<em>bits-per-pixel</em> must be 8, 16 or 32. Less than 8-bit pixels are
not yet supported. <em>Big-endian-flag</em> is non-zero (true) if
multi-byte pixels are interpreted as big endian. Of course this is
meaningless for 8 bits-per-pixel.</p>
<p><em>Depth</em> should be the sum of bits used according to
<em>red-max</em>, <em>green-max</em>, and <em>blue-max</em>, or the
number of bits needed for indices in the colour map, depending on the
value of <em>true-color-flag</em>. Note that some servers will send a
<em>depth</em> that is identical to <em>bits-per-pixel</em> for
historical reasons.</p>
<p>If <em>true-colour-flag</em> is non-zero (true) then the last six
items specify how to extract the red, green and blue intensities from
the pixel value. <em>Red-max</em> is the maximum red value (= 2^n - 1
where <em>n</em> is the number of bits used for red). Note this value is
always in big endian order. <em>Red-shift</em> is the number of shifts
needed to get the red value in a pixel to the least significant bit.
<em>Green-max</em>, <em>green-shift</em> and <em>blue-max</em>,
<em>blue-shift</em> are similar for green and blue. For example, to find
the red value (between 0 and <em>red-max</em>) from a given pixel, do
the following:</p>
<ul>
<li>Swap the pixel value according to <em>big-endian-flag</em> (e.g. if
<em>big-endian-flag</em> is zero (false) and host byte order is big
endian, then swap).</li>
<li>Shift right by <em>red-shift</em>.</li>
<li>AND with <em>red-max</em> (in host byte order).</li>
</ul>
<p>If <em>true-colour-flag</em> is zero (false) then the server uses
pixel values which are not directly composed from the red, green and
blue intensities, but which serve as indices into a colour map. Entries
in the colour map are set by the server using the
<em>SetColourMapEntries</em> message (<a
href="#setcolourmapentries">SetColourMapEntries</a>).</p>
<p>If the <a href="#tight-security-type">Tight Security Type</a> is
activated, the server init message is extended with an interaction
capabilities section:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>2 2 2</p></td>
<td><p><code>U16</code> <code>U16</code> <code>U16</code></p></td>
<td></td>
<td><p><em>number-of-server-messages</em>
<em>number-of-client-messages</em> <em>number-of-encodings</em></p></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td>0</td>
<td><em>padding</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-server-messages</em> repetitions of the
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td><code>CAPABILITY</code></td>
<td><em>server-message</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-client-messages</em> repetitions of the
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td><code>CAPABILITY</code></td>
<td><em>client-message</em></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-encodings</em> repetitions of the
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td><code>CAPABILITY</code></td>
<td><em>encoding</em></td>
</tr>
</tbody>
</table>
<p>The following <em>server-message</em> capabilities are
registered:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Vendor</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>130</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTS_LSDT</code>"</td>
<td>File List Data</td>
</tr>
<tr class="even">
<td>131</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTS_DNDT</code>"</td>
<td>File Download Data</td>
</tr>
<tr class="odd">
<td>132</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTS_UPCN</code>"</td>
<td>File Upload Cancel</td>
</tr>
<tr class="even">
<td>133</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTS_DNFL</code>"</td>
<td>File Download Failed</td>
</tr>
<tr class="odd">
<td>150</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>CUS_EOCU</code>"</td>
<td><a href="#endofcontinuousupdates">EndOfContinuousUpdates</a></td>
</tr>
<tr class="even">
<td>253</td>
<td>"<code>GGI_</code>"</td>
<td>"<code>GII_SERV</code>"</td>
<td><a href="#gii-server-message">gii Server Message</a></td>
</tr>
</tbody>
</table>
<p>The following <em>client-message</em> capabilities are
registered:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Vendor</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>130</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTC_LSRQ</code>"</td>
<td>File List Request</td>
</tr>
<tr class="even">
<td>131</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTC_DNRQ</code>"</td>
<td>File Download Request</td>
</tr>
<tr class="odd">
<td>132</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTC_UPRQ</code>"</td>
<td>File Upload Request</td>
</tr>
<tr class="even">
<td>133</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTC_UPDT</code>"</td>
<td>File Upload Data</td>
</tr>
<tr class="odd">
<td>134</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTC_DNCN</code>"</td>
<td>File Download Cancel</td>
</tr>
<tr class="even">
<td>135</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTC_UPFL</code>"</td>
<td>File Upload Failed</td>
</tr>
<tr class="odd">
<td>136</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>FTC_FCDR</code>"</td>
<td>File Create Directory Request</td>
</tr>
<tr class="even">
<td>150</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>CUC_ENCU</code>"</td>
<td><a href="#enablecontinuousupdates">EnableContinuousUpdates</a></td>
</tr>
<tr class="odd">
<td>151</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>VRECTSEL</code>"</td>
<td>Video Rectangle Selection</td>
</tr>
<tr class="even">
<td>253</td>
<td>"<code>GGI_</code>"</td>
<td>"<code>GII_CLNT</code>"</td>
<td><a href="#gii-client-message">gii Client Message</a></td>
</tr>
</tbody>
</table>
<p>The following <em>encoding</em> capabilities are registered:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Vendor</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>"<code>STDV</code>"</td>
<td>"<code>RAW_____</code>"</td>
<td><a href="#raw-encoding">Raw Encoding</a></td>
</tr>
<tr class="even">
<td>1</td>
<td>"<code>STDV</code>"</td>
<td>"<code>COPYRECT</code>"</td>
<td><a href="#copyrect-encoding">CopyRect Encoding</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td>"<code>STDV</code>"</td>
<td>"<code>RRE_____</code>"</td>
<td><a href="#rre-encoding">RRE Encoding</a></td>
</tr>
<tr class="even">
<td>4</td>
<td>"<code>STDV</code>"</td>
<td>"<code>CORRE___</code>"</td>
<td><a href="#corre-encoding">CoRRE Encoding</a></td>
</tr>
<tr class="odd">
<td>5</td>
<td>"<code>STDV</code>"</td>
<td>"<code>HEXTILE_</code>"</td>
<td><a href="#hextile-encoding">Hextile Encoding</a></td>
</tr>
<tr class="even">
<td>6</td>
<td>"<code>TRDV</code>"</td>
<td>"<code>ZLIB____</code>"</td>
<td><a href="#zlib-encoding">ZLib Encoding</a></td>
</tr>
<tr class="odd">
<td>7</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>TIGHT___</code>"</td>
<td><a href="#tight-encoding">Tight Encoding</a></td>
</tr>
<tr class="even">
<td>8</td>
<td>"<code>TRDV</code>"</td>
<td>"<code>ZLIBHEX_</code>"</td>
<td><a href="#zlibhex-encoding">ZLibHex Encoding</a></td>
</tr>
<tr class="odd">
<td><p>-32</p></td>
<td><p>"<code>TGHT</code>"</p></td>
<td><p>"<code>JPEGQLVL</code>"</p></td>
<td><p><a href="#jpeg-quality-level-pseudo-encoding">JPEG Quality Level
Pseudo-encoding</a></p></td>
</tr>
<tr class="even">
<td><p>-223</p></td>
<td><p>"<code>TGHT</code>"</p></td>
<td><p>"<code>NEWFBSIZ</code>"</p></td>
<td><p><a href="#desktopsize-pseudo-encoding">DesktopSize
Pseudo-encoding</a> (New FB Size)</p></td>
</tr>
<tr class="odd">
<td>-224</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>LASTRECT</code>"</td>
<td><a href="#lastrect-pseudo-encoding">LastRect
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-232</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>POINTPOS</code>"</td>
<td>Pointer Position</td>
</tr>
<tr class="odd">
<td><p>-239</p></td>
<td><p>"<code>TGHT</code>"</p></td>
<td><p>"<code>RCHCURSR</code>"</p></td>
<td><p><a href="#cursor-pseudo-encoding">Cursor Pseudo-encoding</a>
(Rich Cursor)</p></td>
</tr>
<tr class="even">
<td>-240</td>
<td>"<code>TGHT</code>"</td>
<td>"<code>X11CURSR</code>"</td>
<td><a href="#x-cursor-pseudo-encoding">X Cursor
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td><p>-256</p></td>
<td><p>"<code>TGHT</code>"</p></td>
<td><p>"<code>COMPRLVL</code>"</p></td>
<td><p><a href="#compression-level-pseudo-encoding">Compression Level
Pseudo-encoding</a></p></td>
</tr>
<tr class="even">
<td>-305</td>
<td>"<code>GGI_</code>"</td>
<td>"<code>GII_____</code>"</td>
<td><a href="#gii-pseudo-encoding">gii Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td><p>-512</p></td>
<td><p>"<code>TRBO</code>"</p></td>
<td><p>"<code>FINEQLVL</code>"</p></td>
<td><p><a href="#jpeg-fine-grained-quality-level-pseudo-encoding">JPEG
Fine-Grained Quality Level Pseudo-encoding</a></p></td>
</tr>
<tr class="even">
<td><p>-768</p></td>
<td><p>"<code>TRBO</code>"</p></td>
<td><p>"<code>SSAMPLVL</code>"</p></td>
<td><p><a href="#jpeg-subsampling-level-pseudo-encoding">JPEG
Subsampling Level Pseudo-encoding</a></p></td>
</tr>
</tbody>
</table>
<p>Note that the server need not (but it may) list the
"<code>RAW_____</code>" capability since it must be supported
anyway.</p>
<h3 id="client-to-server-messages">Client to Server Messages</h3>
<p>The client to server message types that all servers must support
are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><a href="#setpixelformat">SetPixelFormat</a></td>
</tr>
<tr class="even">
<td>2</td>
<td><a href="#setencodings">SetEncodings</a></td>
</tr>
<tr class="odd">
<td>3</td>
<td><a
href="#framebufferupdaterequest">FramebufferUpdateRequest</a></td>
</tr>
<tr class="even">
<td>4</td>
<td><a href="#keyevent">KeyEvent</a></td>
</tr>
<tr class="odd">
<td>5</td>
<td><a href="#pointerevent">PointerEvent</a></td>
</tr>
<tr class="even">
<td>6</td>
<td><a href="#clientcuttext">ClientCutText</a></td>
</tr>
</tbody>
</table>
<p>Optional message types are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7</td>
<td>FileTransfer</td>
</tr>
<tr class="even">
<td>8</td>
<td>SetScale</td>
</tr>
<tr class="odd">
<td>9</td>
<td>SetServerInput</td>
</tr>
<tr class="even">
<td>10</td>
<td>SetSW</td>
</tr>
<tr class="odd">
<td>11</td>
<td>TextChat</td>
</tr>
<tr class="even">
<td>12</td>
<td>KeyFrameRequest</td>
</tr>
<tr class="odd">
<td>13</td>
<td>KeepAlive</td>
</tr>
<tr class="even">
<td>14</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr class="odd">
<td>15</td>
<td>SetScaleFactor</td>
</tr>
<tr class="even">
<td>16-19</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr class="odd">
<td>20</td>
<td>RequestSession</td>
</tr>
<tr class="even">
<td>21</td>
<td>SetSession</td>
</tr>
<tr class="odd">
<td>80</td>
<td>NotifyPluginStreaming</td>
</tr>
<tr class="even">
<td>127</td>
<td>VMware</td>
</tr>
<tr class="odd">
<td>128</td>
<td>Car Connectivity</td>
</tr>
<tr class="even">
<td>150</td>
<td><a href="#enablecontinuousupdates">EnableContinuousUpdates</a></td>
</tr>
<tr class="odd">
<td>248</td>
<td><a href="#clientfence">ClientFence</a></td>
</tr>
<tr class="even">
<td>249</td>
<td>OLIVE Call Control</td>
</tr>
<tr class="odd">
<td>250</td>
<td><a href="#xvp-client-message">xvp Client Message</a></td>
</tr>
<tr class="even">
<td>251</td>
<td><a href="#setdesktopsize">SetDesktopSize</a></td>
</tr>
<tr class="odd">
<td>252</td>
<td>tight</td>
</tr>
<tr class="even">
<td>253</td>
<td><a href="#gii-client-message">gii Client Message</a></td>
</tr>
<tr class="odd">
<td>254</td>
<td>VMware</td>
</tr>
<tr class="even">
<td>255</td>
<td><a href="#qemu-client-message">QEMU Client Message</a></td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<p>Note that before sending a message with an optional message type a
client must have determined that the server supports the relevant
extension by receiving some extension-specific confirmation from the
server.</p>
<h4 id="setpixelformat">SetPixelFormat</h4>
<p>Sets the format in which pixel values should be sent in
<em>FramebufferUpdate</em> messages. If the client does not send a
<em>SetPixelFormat</em> message then the server sends pixel values in
its natural format as specified in the ServerInit message (<a
href="#serverinit">ServerInit</a>).</p>
<p>If <em>true-colour-flag</em> is zero (false) then this indicates that
a "colour map" is to be used. The server can set any of the entries in
the colour map using the <em>SetColourMapEntries</em> message (<a
href="#setcolourmapentries">SetColourMapEntries</a>). Immediately after
the client has sent this message the colour map is empty, even if
entries had previously been set by the server.</p>
<p>Note that a client must not have an outstanding
<em>FramebufferUpdateRequest</em> when it sends <em>SetPixelFormat</em>
as it would be impossible to determine if the next
<em>FramebufferUpdate</em> is using the new or the previous pixel
format.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 3 16</p></td>
<td><p><code>U8</code></p>
<p><code>PIXEL_FORMAT</code></p></td>
<td><p>0</p></td>
<td><p><em>message-type</em> <em>padding</em>
<em>pixel-format</em></p></td>
</tr>
</tbody>
</table>
<p>where <code>PIXEL_FORMAT</code> is as described in <a
href="#serverinit">ServerInit</a>:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>bits-per-pixel</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>depth</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>big-endian-flag</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>true-colour-flag</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>red-max</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>green-max</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>blue-max</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>red-shift</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>green-shift</em></td>
</tr>
<tr class="even">
<td><p>1 3</p></td>
<td><p><code>U8</code></p></td>
<td><p><em>blue-shift</em> <em>padding</em></p></td>
</tr>
</tbody>
</table>
<h4 id="setencodings">SetEncodings</h4>
<p>Sets the encoding types in which pixel data can be sent by the
server. The order of the encoding types given in this message is a hint
by the client as to its preference (the first encoding specified being
most preferred). The server may or may not choose to make use of this
hint. Pixel data may always be sent in <em>raw</em> encoding even if not
specified explicitly here.</p>
<p>In addition to genuine encodings, a client can request
"pseudo-encodings" to declare to the server that it supports certain
extensions to the protocol. A server which does not support the
extension will simply ignore the pseudo-encoding. Note that this means
the client must assume that the server does not support the extension
until it gets some extension-specific confirmation from the server.</p>
<p>See <a href="#encodings">Encodings</a> for a description of each
encoding and <a href="#pseudo-encodings">Pseudo-encodings</a> for the
meaning of pseudo-encodings.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2</p></td>
<td><p><code>U8</code></p>
<p><code>U16</code></p></td>
<td><p>2</p></td>
<td><p><em>message-type</em> <em>padding</em>
<em>number-of-encodings</em></p></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-encodings</em> repetitions of the
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>S32</code></td>
<td><em>encoding-type</em></td>
</tr>
</tbody>
</table>
<h4 id="framebufferupdaterequest">FramebufferUpdateRequest</h4>
<p>Notifies the server that the client is interested in the area of the
framebuffer specified by <em>x-position</em>, <em>y-position</em>,
<em>width</em> and <em>height</em>. The server usually responds to a
<em>FramebufferUpdateRequest</em> by sending a
<em>FramebufferUpdate</em>. Note however that a single
<em>FramebufferUpdate</em> may be sent in reply to several
<em>FramebufferUpdateRequests</em>.</p>
<p>The server assumes that the client keeps a copy of all parts of the
framebuffer in which it is interested. This means that normally the
server only needs to send incremental updates to the client.</p>
<p>However, if for some reason the client has lost the contents of a
particular area which it needs, then the client sends a
<em>FramebufferUpdateRequest</em> with <em>incremental</em> set to zero
(false). This requests that the server send the entire contents of the
specified area as soon as possible. The area will not be updated using
the <em>CopyRect</em> encoding.</p>
<p>If the client has not lost any contents of the area in which it is
interested, then it sends a <em>FramebufferUpdateRequest</em> with
<em>incremental</em> set to non-zero (true). If and when there are
changes to the specified area of the framebuffer, the server will send a
<em>FramebufferUpdate</em>. Note that there may be an indefinite period
between the <em>FramebufferUpdateRequest</em> and the
<em>FramebufferUpdate</em>.</p>
<p>In the case of a fast client, the client may want to regulate the
rate at which it sends incremental <em>FramebufferUpdateRequests</em> to
avoid hogging the network.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2 2 2 2</p></td>
<td><p><code>U8</code> <code>U8</code> <code>U16</code> <code>U16</code>
<code>U16</code> <code>U16</code></p></td>
<td><p>3</p></td>
<td><p><em>message-type</em> <em>incremental</em> <em>x-position</em>
<em>y-position</em> <em>width</em> <em>height</em></p></td>
</tr>
</tbody>
</table>
<p>A request for an area that partly falls outside the current
framebuffer must be cropped so that it fits within the framebuffer
dimensions.</p>
<p>Note that an empty area can still solicit a
<em>FramebufferUpdate</em> even though that update will only contain
pseudo-encodings.</p>
<h4 id="keyevent">KeyEvent</h4>
<p>A key press or release. <em>Down-flag</em> is non-zero (true) if the
key is now pressed, zero (false) if it is now released. The key itself
is specified using the "keysym" values defined by the X Window
System.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2 4</p></td>
<td><p><code>U8</code> <code>U8</code></p>
<p><code>U32</code></p></td>
<td><p>4</p></td>
<td><p><em>message-type</em> <em>down-flag</em> <em>padding</em>
<em>key</em></p></td>
</tr>
</tbody>
</table>
<p>Auto repeating of keys when a key is held down should be handled on
the client. The rationale being that high latency on the network can
make it seem like a key is being held for a very long time, yet the
problem is that the <em>KeyEvent</em> message releasing the button has
been delayed.</p>
<p>The client should send only repeated "down" <em>KeyEvent</em>
messages, no "up" messages, when a key is automatically repeated. This
allows the server to tell the difference between automatic repeat and
actual repeated entry by the user.</p>
<p>For most ordinary keys, the "keysym" is the same as the corresponding
ASCII value. For full details, see The Xlib Reference Manual, published
by O'Reilly &amp; Associates, or see the header file
<code>&lt;X11/keysymdef.h&gt;</code> from any X Window System
installation. Some other common keys are:</p>
<table>
<thead>
<tr class="header">
<th>Key name</th>
<th>Keysym value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BackSpace</td>
<td>0xff08</td>
</tr>
<tr class="even">
<td>Tab</td>
<td>0xff09</td>
</tr>
<tr class="odd">
<td>Return or Enter</td>
<td>0xff0d</td>
</tr>
<tr class="even">
<td>Escape</td>
<td>0xff1b</td>
</tr>
<tr class="odd">
<td>Insert</td>
<td>0xff63</td>
</tr>
<tr class="even">
<td>Delete</td>
<td>0xffff</td>
</tr>
<tr class="odd">
<td>Home</td>
<td>0xff50</td>
</tr>
<tr class="even">
<td>End</td>
<td>0xff57</td>
</tr>
<tr class="odd">
<td>Page Up</td>
<td>0xff55</td>
</tr>
<tr class="even">
<td>Page Down</td>
<td>0xff56</td>
</tr>
<tr class="odd">
<td>Left</td>
<td>0xff51</td>
</tr>
<tr class="even">
<td>Up</td>
<td>0xff52</td>
</tr>
<tr class="odd">
<td>Right</td>
<td>0xff53</td>
</tr>
<tr class="even">
<td>Down</td>
<td>0xff54</td>
</tr>
<tr class="odd">
<td>F1</td>
<td>0xffbe</td>
</tr>
<tr class="even">
<td>F2</td>
<td>0xffbf</td>
</tr>
<tr class="odd">
<td>F3</td>
<td>0xffc0</td>
</tr>
<tr class="even">
<td>F4</td>
<td>0xffc1</td>
</tr>
<tr class="odd">
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td>F12</td>
<td>0xffc9</td>
</tr>
<tr class="odd">
<td>Shift (left)</td>
<td>0xffe1</td>
</tr>
<tr class="even">
<td>Shift (right)</td>
<td>0xffe2</td>
</tr>
<tr class="odd">
<td>Control (left)</td>
<td>0xffe3</td>
</tr>
<tr class="even">
<td>Control (right)</td>
<td>0xffe4</td>
</tr>
<tr class="odd">
<td>Meta (left)</td>
<td>0xffe7</td>
</tr>
<tr class="even">
<td>Meta (right)</td>
<td>0xffe8</td>
</tr>
<tr class="odd">
<td>Alt (left)</td>
<td>0xffe9</td>
</tr>
<tr class="even">
<td>Alt (right)</td>
<td>0xffea</td>
</tr>
</tbody>
</table>
<p>The interpretation of keysyms is a complex area. In order to be as
widely interoperable as possible the following guidelines should be
used:</p>
<ul>
<li>The "shift state" (i.e. whether either of the Shift keysyms are
down) should only be used as a hint when interpreting a keysym. For
example, on a US keyboard the '#' character is shifted, but on a UK
keyboard it is not. A server with a US keyboard receiving a '#'
character from a client with a UK keyboard will not have been sent any
shift presses. In this case, it is likely that the server will
internally need to "fake" a shift press on its local system, in order to
get a '#' character and not, for example, a '3'.</li>
<li>The difference between upper and lower case keysyms is significant.
This is unlike some of the keyboard processing in the X Window System
which treats them as the same. For example, a server receiving an
uppercase 'A' keysym without any shift presses should interpret it as an
uppercase 'A'. Again this may involve an internal "fake" shift
press.</li>
<li>Servers should ignore "lock" keysyms such as CapsLock and NumLock
where possible. Instead they should interpret each character-based
keysym according to its case. Note that some applications directly
examine the state of CapsLock and NumLock and an extension such as <a
href="#qemu-led-state-pseudo-encoding">QEMU LED State
Pseudo-encoding</a> or <a
href="#vmware-led-state-pseudo-encoding">VMware LED State
Pseudo-encoding</a> could be needed for correct behaviour.</li>
<li>Unlike Shift, the state of modifier keys such as Control and Alt
should be taken as modifying the interpretation of other keysyms. Note
that there are no keysyms for ASCII control characters such as ctrl-a;
these should be generated by viewers sending a Control press followed by
an 'a' press.</li>
<li>On a viewer where modifiers like Control and Alt can also be used to
generate character-based keysyms, the viewer may need to send extra
"release" events in order that the keysym is interpreted correctly. For
example, on a German PC keyboard on Windows, ctrl-alt-q generates the
'@' character. In this case, the viewer needs to send "fake" release
events for Control and Alt in order that the '@' character is
interpreted correctly (ctrl-alt-@ is likely to mean something completely
different to the server).</li>
<li>There is no universal standard for "backward tab" in the X Window
System. On some systems shift+tab gives the keysym "ISO Left Tab", on
others it gives a private "BackTab" keysym and on others it gives "Tab"
and applications tell from the shift state that it means backward-tab
rather than forward-tab. In the RFB protocol the latter approach is
preferred. Viewers should generate a shifted Tab rather than ISO Left
Tab. However, to be backwards-compatible with existing viewers, servers
should also recognise ISO Left Tab as meaning a shifted Tab.</li>
</ul>
<p>Note that extensions such as <a
href="#qemu-extended-key-event-message">QEMU Extended Key Event
Message</a> provide alternative behaviours for keyboard events that do
not follow what is described here.</p>
<h4 id="pointerevent">PointerEvent</h4>
<p>Indicates either pointer movement or a pointer button press or
release. The pointer is now at (<em>x-position</em>,
<em>y-position</em>), and the current state of buttons 1 to 8 are
represented by bits 0 to 7 of <em>button-mask</em> respectively, 0
meaning up, 1 meaning down (pressed).</p>
<p>On a conventional mouse, buttons 1, 2 and 3 correspond to the left,
middle and right buttons on the mouse. On a wheel mouse, each step of
the wheel is represented by a press and release of a certain button.
Button 4 means up, button 5 means down, button 6 means left and button 7
means right.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2 2</p></td>
<td><p><code>U8</code> <code>U8</code> <code>U16</code>
<code>U16</code></p></td>
<td><p>5</p></td>
<td><p><em>message-type</em> <em>button-mask</em> <em>x-position</em>
<em>y-position</em></p></td>
</tr>
</tbody>
</table>
<p>The <a href="#qemu-pointer-motion-change-pseudo-encoding">QEMU
Pointer Motion Change Pseudo-encoding</a> allows for the negotiation of
an alternative interpretation for the <em>x-position</em> and
<em>y-position</em> fields, as relative deltas.</p>
<h4 id="clientcuttext">ClientCutText</h4>
<p>The client has new ISO 8859-1 (Latin-1) text in its cut buffer. Ends
of lines are represented by the linefeed / newline character (value 10)
alone. No carriage-return (value 13) is needed.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 3 4 <em>length</em></p></td>
<td><p><code>U8</code></p>
<p><code>U32</code> <code>U8</code> array</p></td>
<td><p>6</p></td>
<td><p><em>message-type</em> <em>padding</em> <em>length</em>
<em>text</em></p></td>
</tr>
</tbody>
</table>
<p>See also <a href="#extended-clipboard-pseudo-encoding">Extended
Clipboard Pseudo-Encoding</a> which modifies the behaviour of this
message.</p>
<h4 id="enablecontinuousupdates">EnableContinuousUpdates</h4>
<p>This message informs the server to switch between only sending <a
href="#framebufferupdate">FramebufferUpdate</a> messages as a result of
a <a href="#framebufferupdaterequest">FramebufferUpdateRequest</a>
message, or sending <code>FramebufferUpdate</code> messages
continuously.</p>
<p>The client must establish that the server supports this message
before sending it. The client can do so using either the <a
href="#tight-security-type">Tight Security Type</a> authentication, or
using the <a href="#continuousupdates-pseudo-encoding">ContinuousUpdates
Pseudo-encoding</a>.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2 2 2 2</p></td>
<td><p><code>U8</code> <code>U8</code> <code>U16</code> <code>U16</code>
<code>U16</code> <code>U16</code></p></td>
<td><p>150</p></td>
<td><p><em>message-type</em> <em>enable-flag</em> <em>x-position</em>
<em>y-position</em> <em>width</em> <em>height</em></p></td>
</tr>
</tbody>
</table>
<p>If <em>enable-flag</em> is non-zero, then the server can start
sending <code>FramebufferUpdate</code> messages as needed for the area
specified by <em>x-position</em>, <em>y-position</em>, <em>width</em>,
and <em>height</em>. If continuous updates are already active, then they
must remain active and the coordinates must be replaced with the last
message seen.</p>
<p>If <em>enable-flag</em> is zero, then the server must only send
<code>FramebufferUpdate</code> messages as a result of receiving
<code>FramebufferUpdateRequest</code> messages. The server must also
immediately send out a <a
href="#endofcontinuousupdates">EndOfContinuousUpdates</a> message. This
message must be sent out even if continuous updates were already
disabled.</p>
<p>The server must ignore all incremental update requests
(<code>FramebufferUpdateRequest</code> with <em>incremental</em> set to
non-zero) as long as continuous updates are active. Non-incremental
update requests must however be honored, even if the area in such a
request does not overlap the area specified for continuous updates.</p>
<h4 id="clientfence">ClientFence</h4>
<p>A client supporting the <em>Fence</em> extension sends this to
request a synchronisation of the data stream.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 3 4 1 <em>length</em></p></td>
<td><p><code>U8</code></p>
<p><code>U32</code> <code>U8</code> <code>U8</code> array</p></td>
<td><p>248</p></td>
<td><p><em>message-type</em> <em>padding</em> <em>flags</em>
<em>length</em> <em>payload</em></p></td>
</tr>
</tbody>
</table>
<p>The <em>flags</em> byte informs the server if this is a new request,
or a response to a server request sent earlier, as well as what kind of
synchronisation that is desired. The server should not delay the
response more than necessary, even if the synchronisation requirements
would allow it.</p>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><strong>BlockBefore</strong></td>
</tr>
<tr class="even">
<td>1</td>
<td><strong>BlockAfter</strong></td>
</tr>
<tr class="odd">
<td>2</td>
<td><strong>SyncNext</strong></td>
</tr>
<tr class="even">
<td>3-30</td>
<td>Currently unused</td>
</tr>
<tr class="odd">
<td>31</td>
<td><strong>Request</strong></td>
</tr>
</tbody>
</table>
<p>The server should respond with a <a
href="#serverfence">ServerFence</a> with the <strong>Request</strong>
bit cleared, as well as clearing any bits it does not understand. The
remaining bits should remain set in the response. This allows the client
to determine which flags the server supports when new ones are defined
in the future.</p>
<dl>
<dt><strong>BlockBefore</strong></dt>
<dd>
<p>All messages preceding this one must have finished processing and
taken effect before the response is sent.</p>
<p>Messages following this one are unaffected and may be processed in
any order the protocol permits, even before the response is sent.</p>
</dd>
<dt><strong>BlockAfter</strong></dt>
<dd>
<p>All messages following this one must not start processing until the
response is sent.</p>
<p>Messages preceding this one are unaffected and may be processed in
any order the protocol permits, even being delayed until after the
response is sent.</p>
</dd>
<dt><strong>SyncNext</strong></dt>
<dd>
<p>The message following this one must be executed in an atomic manner
so that anything preceding the fence response <strong>must not</strong>
be affected by the message, and anything following the fence response
<strong>must</strong> be affected by the message.</p>
<p>Anything unaffected by the following message can be sent at any time
the protocol permits.</p>
<p>The primary purpose of this synchronisation is to allow safe usage of
stream altering commands such as <a
href="#setpixelformat">SetPixelFormat</a>, which would impose strict
ordering on <a href="#framebufferupdate">FramebufferUpdate</a> messages
even with asynchrounous extensions such as the <a
href="#continuousupdates-pseudo-encoding">ContinuousUpdates
Pseudo-encoding</a>.</p>
<p>If <strong>BlockAfter</strong> is also set then the interaction
between the two flags can be ambiguous. In this case we relax the
requirement for <strong>BlockAfter</strong> and allow the following
message (the one made atomic by <strong>SyncNext</strong>) to be
processed before a response is sent. All messages after that first one
are still subjected to the semantics of <strong>BlockAfter</strong>
however. The behaviour will be similar to the following series of
messages:</p>
<blockquote>
<ol type="1">
<li><em>ClientFence</em> with <strong>SyncNext</strong></li>
<li><em>message made atomic</em></li>
<li><em>ClientFence</em> with <strong>BlockAfter</strong></li>
</ol>
</blockquote>
</dd>
<dt><strong>Request</strong></dt>
<dd>
<p>Indicates that this is a new request and that a response is expected.
If this bit is cleared then this message is a response to an earlier
request.</p>
</dd>
</dl>
<p>The client can also include a chunk of data to differentiate between
responses and to avoid keeping state. This data is specified using
<em>length</em> and <em>payload</em>. The size of this data is limited
to 64 bytes in order to minimise the disturbance to highly parallel
clients and servers.</p>
<h4 id="xvp-client-message">xvp Client Message</h4>
<p>A client supporting the <em>xvp</em> extension sends this to request
that the server initiate a clean shutdown, clean reboot or abrupt reset
of the system whose framebuffer the client is displaying.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1</p></td>
<td><p><code>U8</code></p></td>
<td><p>250</p></td>
<td><p><em>message-type</em> <em>padding</em></p></td>
</tr>
<tr class="even">
<td><p>1 1</p></td>
<td><p><code>U8</code> <code>U8</code></p></td>
<td><p>1</p></td>
<td><p><em>xvp-extension-version</em> <em>xvp-message-code</em></p></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>xvp-message-code</em> are: 2 -
XVP_SHUTDOWN, 3 - XVP_REBOOT, and 4 - XVP_RESET. The client must have
already established that the server supports this extension, by
requesting the <a href="#xvp-pseudo-encoding">xvp
Pseudo-encoding</a>.</p>
<h4 id="setdesktopsize">SetDesktopSize</h4>
<p>Requests a change of desktop size. This message is an extension and
may only be sent if the client has previously received an
<em>ExtendedDesktopSize</em> rectangle. This message also enables
clients to handle configuration of a multi head screen layout within the
framebuffer extents, as described in <a href="#screen-model">Screen
Model</a>.</p>
<p>The server must send an <em>ExtendedDesktopSize</em> rectangle for
every <em>SetDesktopSize</em> message received. Several rectangles may
be sent in a single <em>FramebufferUpdate</em> message, but the
rectangles must not be merged or reordered in any way. Note that
rectangles sent for other reasons may be interleaved with the ones
generated as a result of <em>SetDesktopSize</em> messages.</p>
<p>Upon a successful request the server must send an
<em>ExtendedDesktopSize</em> rectangle to the requesting client with the
exact same information the client provided in the corresponding
<em>SetDesktopSize</em> message. <em>x-position</em> must be set to 1,
indicating a client initiated event, and <em>y-position</em> must be set
to 0, indicating success.</p>
<p>The server must also send an <em>ExtendedDesktopSize</em> rectangle
to all other connected clients, but with <em>x-position</em> set to 2,
indicating a change initiated by another client.</p>
<p>If the server can not or will not satisfy the request, it must send
an <em>ExtendedDesktopSize</em> rectangle to the requesting client with
<em>x-position</em> set to 1 and <em>y-position</em> set to the relevant
error code. All remaining fields are undefined, although the basic
structure must still be followed. The server must not send an
<em>ExtendedDesktopSize</em> rectangle to any other connected
clients.</p>
<p>All <em>ExtendedDesktopSize</em> rectangles that are sent as a result
of a <em>SetDesktopSize</em> message should be sent as soon as
possible.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2 2 1 1 <em>number-of-screens</em> * 16</p></td>
<td><p><code>U8</code></p>
<p><code>U16</code> <code>U16</code> <code>U8</code></p>
<p><code>SCREEN</code> array</p></td>
<td><p>251</p></td>
<td><p><em>message-type</em> <em>padding</em> <em>width</em>
<em>height</em> <em>number-of-screens</em> <em>padding</em>
<em>screens</em></p></td>
</tr>
</tbody>
</table>
<p>The <em>width</em> and <em>height</em> indicates the framebuffer size
requested. This structure is followed by <em>number-of-screens</em>
number of <code>SCREEN</code> structures, which is defined in <a
href="#extendeddesktopsize-pseudo-encoding">ExtendedDesktopSize
Pseudo-encoding</a>:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>id</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>x-position</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>y-position</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>width</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>height</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U32</code></td>
<td><em>flags</em></td>
</tr>
</tbody>
</table>
<p>The <em>id</em> field must be preserved upon modification as it
determines the difference between a moved screen and a newly created
one. The client should make every effort to preserve the fields it does
not wish to modify, including any unknown <em>flags</em> bits.</p>
<h4 id="gii-client-message">gii Client Message</h4>
<p>This message is an extension and may only be sent if the client has
previously received a <a href="#gii-server-message">gii Server
Message</a> confirming that the server supports the General Input
Interface extension.</p>
<h6 id="version">Version</h6>
<p>The client response to a <em>gii</em> Version message from the server
is the following response:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>1 or 129</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>EU16</code></td>
<td>2</td>
<td><em>length</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>EU16</code></td>
<td>1</td>
<td><em>version</em></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit
indicating big endian if set, and little endian if cleared. The rest of
the bits are the actual message sub type.</p>
<p><em>version</em> is set by the client and ultimately decides the
version of <em>gii</em> protocol extension to use. It should be in the
range given by the server in the <em>gii</em> Version message. If the
server doesn't support any version that the client supports, the client
should instead stop using the <em>gii</em> extension at this point.</p>
<h6 id="device-creation">Device Creation</h6>
<p>After establishing the <em>gii</em> protocol extension version, the
client proceeds by requesting creation of one or more devices.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>2 or 130</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr class="odd">
<td><p>2 31</p></td>
<td><p><code>EU16</code> <code>U8</code> array</p></td>
<td><p>56 + <em>num-valuators</em> * 116</p></td>
<td><p><em>length</em> <em>device-name</em></p></td>
</tr>
<tr class="even">
<td><p>1 4 4 4 4 4 4 <em>num-valuators</em> * 116</p></td>
<td><p><code>U8</code> <code>EU32</code> <code>EU32</code>
<code>EVENT_MASK</code> <code>EU32</code> <code>EU32</code>
<code>EU32</code> <code>VALUATOR</code></p></td>
<td><p>0</p></td>
<td><p><em>nul-terminator</em> <em>vendor-id</em> <em>product-id</em>
<em>can-generate</em> <em>num-registers</em> <em>num-valuators</em>
<em>num-buttons</em></p></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit
indicating big endian if set, and little endian if cleared. The rest of
the bits are the actual message sub type.</p>
<p><code>EVENT_MASK</code> is a bit-field indicating which events the
device can generate.</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Bit name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00000020</td>
<td>Key press</td>
</tr>
<tr class="even">
<td>0x00000040</td>
<td>Key release</td>
</tr>
<tr class="odd">
<td>0x00000080</td>
<td>Key repeat</td>
</tr>
<tr class="even">
<td>0x00000100</td>
<td>Pointer relative</td>
</tr>
<tr class="odd">
<td>0x00000200</td>
<td>Pointer absolute</td>
</tr>
<tr class="even">
<td>0x00000400</td>
<td>Pointer button press</td>
</tr>
<tr class="odd">
<td>0x00000800</td>
<td>Pointer button release</td>
</tr>
<tr class="even">
<td>0x00001000</td>
<td>Valuator relative</td>
</tr>
<tr class="odd">
<td>0x00002000</td>
<td>Valuator absolute</td>
</tr>
</tbody>
</table>
<p>and <code>VALUATOR</code> is</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>4 74</p></td>
<td><p><code>EU32</code> <code>U8</code> array</p></td>
<td></td>
<td><p><em>index</em> <em>long-name</em></p></td>
</tr>
<tr class="even">
<td><p>1 4</p></td>
<td><p><code>U8</code> <code>U8</code> array</p></td>
<td><p>0</p></td>
<td><p><em>nul-terminator</em> <em>short-name</em></p></td>
</tr>
<tr class="odd">
<td><p>1 4 4 4 4 4 4 4 4</p></td>
<td><p><code>U8</code> <code>ES32</code> <code>ES32</code>
<code>ES32</code> <code>EU32</code> <code>ES32</code> <code>ES32</code>
<code>ES32</code> <code>ES32</code></p></td>
<td><p>0</p></td>
<td><p><em>nul-terminator</em> <em>range-min</em> <em>range-center</em>
<em>range-max</em> <em>SI-unit</em> <em>SI-add</em> <em>SI-mul</em>
<em>SI-div</em> <em>SI-shift</em></p></td>
</tr>
</tbody>
</table>
<p>The <em>SI-unit</em> field is defined as:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>SI-unit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td></td>
<td>unknown</td>
</tr>
<tr class="even">
<td>1</td>
<td>s</td>
<td>time</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1/s</td>
<td>frequency</td>
</tr>
<tr class="even">
<td>3</td>
<td>m</td>
<td>length</td>
</tr>
<tr class="odd">
<td>4</td>
<td>m/s</td>
<td>velocity</td>
</tr>
<tr class="even">
<td>5</td>
<td>m/s^2</td>
<td>acceleration</td>
</tr>
<tr class="odd">
<td>6</td>
<td>rad</td>
<td>angle</td>
</tr>
<tr class="even">
<td>7</td>
<td>rad/s</td>
<td>angular velocity</td>
</tr>
<tr class="odd">
<td>8</td>
<td>rad/s^2</td>
<td>angular acceleration</td>
</tr>
<tr class="even">
<td>9</td>
<td>m^2</td>
<td>area</td>
</tr>
<tr class="odd">
<td>10</td>
<td>m^3</td>
<td>volume</td>
</tr>
<tr class="even">
<td>11</td>
<td>kg</td>
<td>mass</td>
</tr>
<tr class="odd">
<td>12</td>
<td>N (kg*m/s^2)</td>
<td>force</td>
</tr>
<tr class="even">
<td>13</td>
<td>N/m^2 (Pa)</td>
<td>pressure</td>
</tr>
<tr class="odd">
<td>14</td>
<td>Nm</td>
<td>torque</td>
</tr>
<tr class="even">
<td>15</td>
<td>Nm, VAs, J</td>
<td>energy</td>
</tr>
<tr class="odd">
<td>16</td>
<td>Nm/s, VA, W</td>
<td>power</td>
</tr>
<tr class="even">
<td>17</td>
<td>K</td>
<td>temperature</td>
</tr>
<tr class="odd">
<td>18</td>
<td>A</td>
<td>current</td>
</tr>
<tr class="even">
<td>19</td>
<td>V (kg*m^2/(As^3))</td>
<td>voltage</td>
</tr>
<tr class="odd">
<td>20</td>
<td>V/A (Ohm)</td>
<td>resistance</td>
</tr>
<tr class="even">
<td>21</td>
<td>As/V</td>
<td>capacity</td>
</tr>
<tr class="odd">
<td>22</td>
<td>Vs/A</td>
<td>inductivity</td>
</tr>
</tbody>
</table>
<p>The <em>SI-add</em>, <em>SI-mul</em>, <em>SI-div</em> and
<em>SI-shift</em> fields of the <code>VALUATOR</code> indicate how the
raw value should be translated to the SI-unit using the below
formula.</p>
<blockquote>
<p>float SI = (float) (SI_add + value[n]) * (float) SI_mul / (float)
SI_div * pow(2.0, SI_shift);</p>
</blockquote>
<p>Setting <em>SI-mul</em> to zero indicates that the valuator is
non-linear or that the factor is unknown.</p>
<h6 id="device-destruction">Device Destruction</h6>
<p>The client can destroy a device with a device destruct message.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>3 or 131</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr class="odd">
<td><p>2 4</p></td>
<td><p><code>EU16</code> <code>EU32</code></p></td>
<td><p>4</p></td>
<td><p><em>length</em> <em>device-origin</em></p></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit
indicating big endian if set, and little endian if cleared. The rest of
the bits are the actual message sub type.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device
creation request.</p>
<h6 id="injecting-events">Injecting Events</h6>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td><p>1 2</p></td>
<td><p><code>U8</code> <code>EU16</code></p></td>
<td><p>0 or 128</p></td>
<td><p><em>endian-and-sub-type</em> <em>length</em></p></td>
</tr>
</tbody>
</table>
<p>followed by <em>length</em> bytes of <code>EVENT</code> entries</p>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit
indicating big endian if set, and little endian if cleared. The rest of
the bits are the actual message sub type.</p>
<p><code>EVENT</code> is one of <code>KEY_EVENT</code>,
<code>PTR_MOVE_EVENT</code>, <code>PTR_BUTTON_EVENT</code> and
<code>VALUATOR_EVENT</code>.</p>
<p><code>KEY_EVENT</code> is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>24</td>
<td><em>event-size</em></td>
</tr>
<tr class="even">
<td><p>1 2 4 4 4 4 4</p></td>
<td><p><code>U8</code> <code>EU16</code> <code>EU32</code>
<code>EU32</code> <code>EU32</code> <code>EU32</code>
<code>EU32</code></p></td>
<td><p>5, 6 or 7</p></td>
<td><p><em>event-type</em> <em>padding</em> <em>device-origin</em>
<em>modifiers</em> <em>symbol</em> <em>label</em>
<em>button</em></p></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 5 - key pressed, 6 -
key released and 7 - key repeat. XXX describe <em>modifiers</em>,
<em>symbol</em>, <em>label</em> and <em>button</em>. Meanwhile, see <a
href="http://www.ggi-project.org/documentation/libgii/current/gii_key_event.3.html">http://www.ggi-project.org/documentation/libgii/current/gii_key_event.3.html</a>
for details.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device
creation request.</p>
<p><code>PTR_MOVE_EVENT</code> is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>24</td>
<td><em>event-size</em></td>
</tr>
<tr class="even">
<td><p>1 2 4 4 4 4 4</p></td>
<td><p><code>U8</code> <code>EU16</code> <code>EU32</code>
<code>ES32</code> <code>ES32</code> <code>ES32</code>
<code>ES32</code></p></td>
<td><p>8 or 9</p></td>
<td><p><em>event-type</em> <em>padding</em> <em>device-origin</em>
<em>x</em> <em>y</em> <em>z</em> <em>wheel</em></p></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 8 - pointer relative
and 9 - pointer absolute.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device
creation request.</p>
<p><code>PTR_BUTTON_EVENT</code> is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>12</td>
<td><em>event-size</em></td>
</tr>
<tr class="even">
<td><p>1 2 4 4</p></td>
<td><p><code>U8</code> <code>EU16</code> <code>EU32</code>
<code>EU32</code></p></td>
<td><p>10 or 11</p></td>
<td><p><em>event-type</em> <em>padding</em> <em>device-origin</em>
<em>button-number</em></p></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 10 - pointer button
press and 11 - pointer button release.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device
creation request.</p>
<p><em>button-number</em> 1 is the primary or left button,
<em>button-number</em> 2 is the secondary or right button and
<em>button-number</em> 3 is the tertiary or middle button. Other values
for <em>button-number</em> are also valid.</p>
<p><code>VALUATOR_EVENT</code> is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>16 + 4 * <em>count</em></td>
<td><em>event-size</em></td>
</tr>
<tr class="even">
<td><p>1 2 4 4 4 4 * <em>count</em></p></td>
<td><p><code>U8</code> <code>EU16</code> <code>EU32</code>
<code>EU32</code> <code>EU32</code> <code>ES32</code> array</p></td>
<td><p>12 or 13</p></td>
<td><p><em>event-type</em> <em>padding</em> <em>device-origin</em>
<em>first</em> <em>count</em> <em>value</em></p></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>event-type</em> are: 12 - relative
valuator and 13 - absolute valuator.</p>
<p><em>device-origin</em> is the handle retrieved with a prior device
creation request.</p>
<p>The event reports <em>count</em> valuators starting with
<em>first</em>.</p>
<h4 id="qemu-client-message">QEMU Client Message</h4>
<p>This message may only be sent if the client has previously received a
<em>FrameBufferUpdate</em> that confirms support for the intended
<em>submessage-type</em>. Every <code>QEMU Client Message</code> begins
with a standard header</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1</p></td>
<td><p><code>U8</code> <code>U8</code></p></td>
<td><p>255</p></td>
<td><p><em>message-type</em> <em>submessage-type</em></p></td>
</tr>
</tbody>
</table>
<p>This header is then followed by arbitrary data whose format is
determined by the <em>submessage-type</em>. Possible values for
<em>submessage-type</em> and their associated pseudo encodings are</p>
<table>
<thead>
<tr class="header">
<th>Submessage Type</th>
<th>Pseudo Encoding</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>-258</td>
<td>Extended key events</td>
</tr>
<tr class="even">
<td>1</td>
<td>-259</td>
<td>Audio</td>
</tr>
</tbody>
</table>
<h6 id="qemu-extended-key-event-message">QEMU Extended Key Event
Message</h6>
<p>This submessage allows the client to send an extended key event
containing a keycode, in addition to a keysym. The advantage of
providing the keycode is that it enables the server to interpret the key
event independently of the clients' locale specific keymap. This can be
important for virtual desktops whose key input device requires
scancodes, for example, virtual machines emulating a PS/2 keycode. Prior
to this extension, RFB servers for such virtualization software would
have to be configured with a keymap matching the client. With this
extension it is sufficient for the guest operating system to be
configured with the matching keymap. The VNC server is keymap
independent.</p>
<p>The full message is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td><p>1 2 4 4</p></td>
<td><p><code>U8</code> <code>U16</code> <code>U32</code>
<code>U32</code></p></td>
<td><p>0</p></td>
<td><p><em>submessage-type</em> <em>down-flag</em> <em>keysym</em>
<em>keycode</em></p></td>
</tr>
</tbody>
</table>
<p>The <em>keysym</em> and <em>down-flag</em> fields also take the same
values as described for the <a href="#keyevent">KeyEvent</a> message.
Auto repeating behaviour of keys is also as described for the <a
href="#keyevent">KeyEvent</a> message.</p>
<p>The <em>keycode</em> is the XT keycode that produced the
<em>keysym</em>. An XT keycode is an XT make scancode sequence encoded
to fit in a single <code>U32</code> quantity. Single byte XT scancodes
with a byte value less than 0x7f are encoded as is. 2-byte XT scancodes
whose first byte is 0xe0 and second byte is less than 0x7f are encoded
with the high bit of the first byte set. Some example mappings are</p>
<table>
<thead>
<tr class="header">
<th>XT scancode</th>
<th>X11 keysym</th>
<th>RFB keycode</th>
<th>down-flag</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x1e</td>
<td>XK_A (0x41)</td>
<td>0x1e</td>
<td>1</td>
</tr>
<tr class="even">
<td>0x9e</td>
<td>XK_A (0x41)</td>
<td>0x1e</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0xe0 0x4d</td>
<td>XK_Right (0xff53)</td>
<td>0xcd</td>
<td>1</td>
</tr>
<tr class="even">
<td>0xe0 0xcd</td>
<td>XK_Right (0xff53)</td>
<td>0xcd</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>The multi-byte scancode sequence for the Print/SysRq key SHOULD be
sent as 0x54, regardless of what modifier keys are currently pressed.
For backwards compatibility servers SHOULD also accept 0xb7 as a synonym
for 0x54.</p>
<p>The multi-byte scancode sequence for the Pause/Break key MUST be sent
as 0xc6, regardless of what modifier keys are currently pressed.</p>
<p>An unknown keysym should have the value 0. The client must not send a
QEMU Extended Key Event Message if the keycode isn't known. Instead a
standard <a href="#keyevent">KeyEvent</a> message should be used.</p>
<h6 id="qemu-audio-client-message">QEMU Audio Client Message</h6>
<p>This submessage allows the client to control how the audio data
stream is received. There are three operations that can be invoked with
this submessage, the payload varies according to which operation is
requested.</p>
<p>The first operation enables audio capture from the server:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td>0</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>After invoking this operation, the client will receive a <a
href="#qemu-audio-server-message">QEMU Audio Server Message</a> when an
audio stream begins.</p>
<p>The second operation is the inverse, to disable audio capture on the
server:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td>1</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>Due to inherant race conditions in the protocol, after invoking this
operation, the client may still receive further <a
href="#qemu-audio-server-message">QEMU Audio Server Message</a> messages
for a short time.</p>
<p>The third and final operation is to set the audio sample format. This
should be set before audio capture is enabled on the server, otherwise
the client will not be able to reliably interpret the receiving audio
buffers:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr class="odd">
<td><p>2 1 1 4</p></td>
<td><p><code>U16</code> <code>U8</code> <code>U8</code>
<code>U32</code></p></td>
<td><p>2</p></td>
<td><p><em>operation</em> <em>sample-format</em> <em>nchannels</em>
<em>frequency</em></p></td>
</tr>
</tbody>
</table>
<p>The <em>sample-format</em> field must take one of the following
values, and this describes the number of bytes that each sample will
consume:</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>No. of bytes</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td><code>U8</code></td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td><code>S8</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td><code>U16</code></td>
</tr>
<tr class="even">
<td>3</td>
<td>2</td>
<td><code>S16</code></td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
<td><code>U32</code></td>
</tr>
<tr class="even">
<td>5</td>
<td>4</td>
<td><code>S32</code></td>
</tr>
</tbody>
</table>
<p>The <em>nchannels</em> field must be either <code>1</code> (mono) or
<code>2</code> (stereo).</p>
<h3 id="server-to-client-messages">Server to Client Messages</h3>
<p>The server to client message types that all clients must support
are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><a href="#framebufferupdate">FramebufferUpdate</a></td>
</tr>
<tr class="even">
<td>1</td>
<td><a href="#setcolourmapentries">SetColourMapEntries</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td><a href="#bell">Bell</a></td>
</tr>
<tr class="even">
<td>3</td>
<td><a href="#servercuttext">ServerCutText</a></td>
</tr>
</tbody>
</table>
<p>Optional message types are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td>ResizeFrameBuffer</td>
</tr>
<tr class="even">
<td>5</td>
<td>KeyFrameUpdate</td>
</tr>
<tr class="odd">
<td>6</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr class="even">
<td>7</td>
<td>FileTransfer</td>
</tr>
<tr class="odd">
<td>8-10</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr class="even">
<td>11</td>
<td>TextChat</td>
</tr>
<tr class="odd">
<td>12</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr class="even">
<td>13</td>
<td>KeepAlive</td>
</tr>
<tr class="odd">
<td>14</td>
<td>Possibly used in UltraVNC</td>
</tr>
<tr class="even">
<td>15</td>
<td>ResizeFrameBuffer</td>
</tr>
<tr class="odd">
<td>127</td>
<td>VMware</td>
</tr>
<tr class="even">
<td>128</td>
<td>Car Connectivity</td>
</tr>
<tr class="odd">
<td>150</td>
<td><a href="#endofcontinuousupdates">EndOfContinuousUpdates</a></td>
</tr>
<tr class="even">
<td>173</td>
<td>ServerState</td>
</tr>
<tr class="odd">
<td>248</td>
<td><a href="#serverfence">ServerFence</a></td>
</tr>
<tr class="even">
<td>249</td>
<td>OLIVE Call Control</td>
</tr>
<tr class="odd">
<td>250</td>
<td><a href="#xvp-server-message">xvp Server Message</a></td>
</tr>
<tr class="even">
<td>252</td>
<td>tight</td>
</tr>
<tr class="odd">
<td>253</td>
<td><a href="#gii-server-message">gii Server Message</a></td>
</tr>
<tr class="even">
<td>254</td>
<td>VMware</td>
</tr>
<tr class="odd">
<td>255</td>
<td><a href="#qemu-server-message">QEMU Server Message</a></td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA<a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p>
<p>Note that before sending a message with an optional message type a
server must have determined that the client supports the relevant
extension by receiving some extension-specific confirmation from the
client; usually a request for a given pseudo-encoding.</p>
<h4 id="framebufferupdate">FramebufferUpdate</h4>
<p>A framebuffer update consists of a sequence of rectangles of pixel
data which the client should put into its framebuffer. It is sent in
response to a <em>FramebufferUpdateRequest</em> from the client. Note
that there may be an indefinite period between the
<em>FramebufferUpdateRequest</em> and the
<em>FramebufferUpdate</em>.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2</p></td>
<td><p><code>U8</code></p>
<p><code>U16</code></p></td>
<td><p>0</p></td>
<td><p><em>message-type</em> <em>padding</em>
<em>number-of-rectangles</em></p></td>
</tr>
</tbody>
</table>
<p>This is followed by <em>number-of-rectangles</em> rectangles of pixel
data. Each rectangle consists of:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>x-position</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>y-position</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>width</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>height</em></td>
</tr>
<tr class="odd">
<td>4</td>
<td><code>S32</code></td>
<td><em>encoding-type</em></td>
</tr>
</tbody>
</table>
<p>followed by the pixel data in the specified encoding. See <a
href="#encodings">Encodings</a> for the format of the data for each
encoding and <a href="#pseudo-encodings">Pseudo-encodings</a> for the
meaning of pseudo-encodings.</p>
<p>Note that a framebuffer update marks a transition from one valid
framebuffer state to another. That means that a single update handles
all received <em>FramebufferUpdateRequest</em> up to the point where the
update is sent out.</p>
<p>However, because there is no strong connection between a
<em>FramebufferUpdateRequest</em> and a subsequent
<em>FramebufferUpdate</em>, a client that has more than one
<em>FramebufferUpdateRequest</em> pending at any given time cannot be
sure that it has received all framebuffer updates.</p>
<p>See the <a href="#lastrect-pseudo-encoding">LastRect
Pseudo-encoding</a> for an extension to this message.</p>
<h4 id="setcolourmapentries">SetColourMapEntries</h4>
<p>When the pixel format uses a "colour map", this message tells the
client that the specified pixel values should be mapped to the given RGB
intensities.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1 2 2</p></td>
<td><p><code>U8</code></p>
<p><code>U16</code> <code>U16</code></p></td>
<td><p>1</p></td>
<td><p><em>message-type</em> <em>padding</em> <em>first-colour</em>
<em>number-of-colours</em></p></td>
</tr>
</tbody>
</table>
<p>followed by <em>number-of-colours</em> repetitions of the
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>red</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>green</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>blue</em></td>
</tr>
</tbody>
</table>
<h4 id="bell">Bell</h4>
<p>Ring a bell on the client if it has one.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>2</td>
<td><em>message-type</em></td>
</tr>
</tbody>
</table>
<h4 id="servercuttext">ServerCutText</h4>
<p>The server has new ISO 8859-1 (Latin-1) text in its cut buffer. Ends
of lines are represented by the linefeed / newline character (value 10)
alone. No carriage-return (value 13) is needed.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 3 4 <em>length</em></p></td>
<td><p><code>U8</code></p>
<p><code>U32</code> <code>U8</code> array</p></td>
<td><p>3</p></td>
<td><p><em>message-type</em> <em>padding</em> <em>length</em>
<em>text</em></p></td>
</tr>
</tbody>
</table>
<p>See also <a href="#extended-clipboard-pseudo-encoding">Extended
Clipboard Pseudo-Encoding</a> which modifies the behaviour of this
message.</p>
<h4 id="endofcontinuousupdates">EndOfContinuousUpdates</h4>
<p>This message is sent whenever the server sees a <a
href="#enablecontinuousupdates">EnableContinuousUpdates</a> message with
<em>enable</em> set to a non-zero value. It indicates that the server
has stopped sending continuous updates and is now only reacting to <a
href="#framebufferupdaterequest">FramebufferUpdateRequest</a>
messages.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>150</td>
<td><em>message-type</em></td>
</tr>
</tbody>
</table>
<h4 id="serverfence">ServerFence</h4>
<p>A server supporting the <em>Fence</em> extension sends this to
request a synchronisation of the data stream.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 3 4 1 <em>length</em></p></td>
<td><p><code>U8</code></p>
<p><code>U32</code> <code>U8</code> <code>U8</code> array</p></td>
<td><p>248</p></td>
<td><p><em>message-type</em> <em>padding</em> <em>flags</em>
<em>length</em> <em>payload</em></p></td>
</tr>
</tbody>
</table>
<p>The format and semantics is identical to <a
href="#clientfence">ClientFence</a>, but with the roles of the client
and server reversed.</p>
<h4 id="xvp-server-message">xvp Server Message</h4>
<p>This has the following format:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1</p></td>
<td><p><code>U8</code></p></td>
<td><p>250</p></td>
<td><p><em>message-type</em> <em>padding</em></p></td>
</tr>
<tr class="even">
<td><p>1 1</p></td>
<td><p><code>U8</code> <code>U8</code></p></td>
<td><p>1</p></td>
<td><p><em>xvp-extension-version</em> <em>xvp-message-code</em></p></td>
</tr>
</tbody>
</table>
<p>The possible values for <em>xvp-message-code</em> are: 0 - XVP_FAIL
and 1 -XVP_INIT.</p>
<p>A server which supports the <em>xvp</em> extension declares this by
sending a message with an XVP_INIT <em>xvp-message-code</em> when it
receives a request from the client to use the <a
href="#xvp-pseudo-encoding">xvp Pseudo-encoding</a>. The server must
specify in this message the highest <em>xvp-extension-version</em> it
supports: the client may assume that the server supports all versions
from 1 up to this value. The client is then free to use any supported
version. Currently, only version 1 is defined.</p>
<p>A server which subsequently receives an <a
href="#xvp-client-message">xvp Client Message</a> requesting an
operation which it is unable to perform, informs the client of this by
sending a message with an XVP_FAIL <em>xvp-message-code</em>, and the
same <em>xvp-extension-version</em> as included in the client's
operation request.</p>
<h4 id="gii-server-message">gii Server Message</h4>
<p>This message is an extension and may only be sent if the server has
previously received a <a href="#setencodings">SetEncodings</a> message
confirming that the client supports the General Input Interface
extension via the <a href="#gii-pseudo-encoding">gii
Pseudo-encoding</a>.</p>
<h6 id="version-1">Version</h6>
<p>The server response from a server with <em>gii</em> capabilities to a
client declaring <em>gii</em> capabilities is a <em>gii</em> version
message:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>SUB_TYPE</code></td>
<td>1 or 129</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>EU16</code></td>
<td>4</td>
<td><em>length</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>EU16</code></td>
<td>1</td>
<td><em>maximum-version</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>EU16</code></td>
<td>1</td>
<td><em>minimum-version</em></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit
indicating big endian if set, and little endian if cleared. The rest of
the bits are the actual message sub type.</p>
<h6 id="device-creation-response">Device Creation Response</h6>
<p>The server response to a <em>gii</em> Device Creation request from
the client is the following response:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>253</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>SUB_TYPE</code></td>
<td>2 or 130</td>
<td><em>endian-and-sub-type</em></td>
</tr>
<tr class="odd">
<td><p>2 4</p></td>
<td><p><code>EU16</code> <code>EU32</code></p></td>
<td><p>4</p></td>
<td><p><em>length</em> <em>device-origin</em></p></td>
</tr>
</tbody>
</table>
<p><em>endian-and-sub-type</em> is a bit-field with the leftmost bit
indicating big endian if set, and little endian if cleared. The rest of
the bits are the actual message sub type.</p>
<p><em>device-origin</em> is used as a handle to the device in
subsequent communications. A <em>device-origin</em> of zero indicates
device creation failure.</p>
<h4 id="qemu-server-message">QEMU Server Message</h4>
<p>This message may only be sent if the client has previously received a
<em>FrameBufferUpdate</em> that confirms support for the intended
<em>submessage-type</em>. Every <code>QEMU Server Message</code> begins
with a standard header</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 1</p></td>
<td><p><code>U8</code> <code>U8</code></p></td>
<td><p>255</p></td>
<td><p><em>message-type</em> <em>submessage-type</em></p></td>
</tr>
</tbody>
</table>
<p>This header is then followed by arbitrary data whose format is
determined by the <em>submessage-type</em>. Possible values for
<em>submessage-type</em> and their associated pseudo encodings are</p>
<table>
<thead>
<tr class="header">
<th>Submessage Type</th>
<th>Pseudo Encoding</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>-259</td>
<td>Audio</td>
</tr>
</tbody>
</table>
<p>Submessage type 0 is unused, since the <a
href="#qemu-extended-key-event-pseudo-encoding">QEMU Extended Key Event
Pseudo-encoding</a> does not require any server messages.</p>
<h6 id="qemu-audio-server-message">QEMU Audio Server Message</h6>
<p>This submessage allows the server to send an audio data stream to the
client. There are three operations that can be invoked with this
submessage, the payload varies according to which operation is
requested.</p>
<p>The first operation informs the client that an audio stream is about
to start</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td>1</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>The second operation informs the client that an audio stream has now
finished:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td>0</td>
<td><em>operation</em></td>
</tr>
</tbody>
</table>
<p>The third and final operation is to provide audio data.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td>255</td>
<td><em>message-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>1</td>
<td><em>submessage-type</em></td>
</tr>
<tr class="odd">
<td><p>2 4 <em>data-length</em></p></td>
<td><p><code>U16</code> <code>U32</code> <code>U8</code> array</p></td>
<td><p>2</p></td>
<td><p><em>operation</em> <em>data-length</em> <em>data</em></p></td>
</tr>
</tbody>
</table>
<p>The <em>data-length</em> will be a multiple of
(<em>sample-format</em> * <em>nchannels</em>) as requested by the client
in an earlier <a href="#qemu-audio-client-message">QEMU Audio Client
Message</a>.</p>
<h3 id="encodings">Encodings</h3>
<p>The encodings defined in this document are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><a href="#raw-encoding">Raw Encoding</a></td>
</tr>
<tr class="even">
<td>1</td>
<td><a href="#copyrect-encoding">CopyRect Encoding</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td><a href="#rre-encoding">RRE Encoding</a></td>
</tr>
<tr class="even">
<td>4</td>
<td><a href="#corre-encoding">CoRRE Encoding</a></td>
</tr>
<tr class="odd">
<td>5</td>
<td><a href="#hextile-encoding">Hextile Encoding</a></td>
</tr>
<tr class="even">
<td>6</td>
<td><a href="#zlib-encoding">zlib Encoding</a></td>
</tr>
<tr class="odd">
<td>7</td>
<td><a href="#tight-encoding">Tight Encoding</a></td>
</tr>
<tr class="even">
<td>8</td>
<td><a href="#zlibhex-encoding">zlibhex Encoding</a></td>
</tr>
<tr class="odd">
<td>16</td>
<td><a href="#zrle-encoding">ZRLE Encoding</a></td>
</tr>
<tr class="even">
<td>21</td>
<td><a href="#jpeg-encoding">JPEG Encoding</a></td>
</tr>
<tr class="odd">
<td>50</td>
<td><a href="#open-h.264-encoding">Open H.264 Encoding</a></td>
</tr>
<tr class="even">
<td>-260</td>
<td><a href="#tight-png-encoding">Tight PNG Encoding</a></td>
</tr>
</tbody>
</table>
<p>The pseudo-encodings defined in this document are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-23 to -32</td>
<td><a href="#jpeg-quality-level-pseudo-encoding">JPEG Quality Level
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-223</td>
<td><a href="#desktopsize-pseudo-encoding">DesktopSize
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-224</td>
<td><a href="#lastrect-pseudo-encoding">LastRect
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-239</td>
<td><a href="#cursor-pseudo-encoding">Cursor Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-240</td>
<td><a href="#x-cursor-pseudo-encoding">X Cursor
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-247 to -256</td>
<td><a href="#compression-level-pseudo-encoding">Compression Level
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-257</td>
<td><a href="#qemu-pointer-motion-change-pseudo-encoding">QEMU Pointer
Motion Change Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-258</td>
<td><a href="#qemu-extended-key-event-pseudo-encoding">QEMU Extended Key
Event Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-259</td>
<td><a href="#qemu-audio-pseudo-encoding">QEMU Audio
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-261</td>
<td><a href="#qemu-led-state-pseudo-encoding">QEMU LED State
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-305</td>
<td><a href="#gii-pseudo-encoding">gii Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-307</td>
<td><a href="#desktopname-pseudo-encoding">DesktopName
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-308</td>
<td><a href="#extendeddesktopsize-pseudo-encoding">ExtendedDesktopSize
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-309</td>
<td><a href="#xvp-pseudo-encoding">xvp Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-312</td>
<td><a href="#fence-pseudo-encoding">Fence Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-313</td>
<td><a href="#continuousupdates-pseudo-encoding">ContinuousUpdates
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-314</td>
<td><a href="#cursor-with-alpha-pseudo-encoding">Cursor With Alpha
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>-412 to -512</td>
<td><a href="#jpeg-fine-grained-quality-level-pseudo-encoding">JPEG
Fine-Grained Quality Level Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>-763 to -768</td>
<td><a href="#jpeg-subsampling-level-pseudo-encoding">JPEG Subsampling
Level Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>0x574d5664</td>
<td><a href="#vmware-cursor-pseudo-encoding">VMware Cursor
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>0x574d5665</td>
<td><a href="#vmware-cursor-state-pseudo-encoding">VMware Cursor State
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>0x574d5666</td>
<td><a href="#vmware-cursor-position-pseudo-encoding">VMware Cursor
Position Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>0x574d5667</td>
<td><a href="#vmware-key-repeat-pseudo-encoding">VMware Key Repeat
Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>0x574d5668</td>
<td><a href="#vmware-led-state-pseudo-encoding">VMware LED state
Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>0x574d5669</td>
<td><a href="#vmware-display-mode-change-pseudo-encoding">VMware Display
Mode Change Pseudo-encoding</a></td>
</tr>
<tr class="even">
<td>0x574d566a</td>
<td><a href="#vmware-virtual-machine-state-pseudo-encoding">VMware
Virtual Machine State Pseudo-encoding</a></td>
</tr>
<tr class="odd">
<td>0xc0a1e5ce</td>
<td><a href="#extended-clipboard-pseudo-encoding">Extended Clipboard
Pseudo-encoding</a></td>
</tr>
</tbody>
</table>
<p>Other registered encodings are:</p>
<table>
<thead>
<tr class="header">
<th>Number</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>9</td>
<td>Ultra</td>
</tr>
<tr class="even">
<td>10</td>
<td>Ultra2</td>
</tr>
<tr class="odd">
<td>15</td>
<td>TRLE</td>
</tr>
<tr class="even">
<td>17</td>
<td>Hitachi ZYWRLE</td>
</tr>
<tr class="odd">
<td>20</td>
<td>H.264</td>
</tr>
<tr class="even">
<td>22</td>
<td>JRLE</td>
</tr>
<tr class="odd">
<td>1000 to 1002</td>
<td>Apple Inc.</td>
</tr>
<tr class="even">
<td>1011</td>
<td>Apple Inc.</td>
</tr>
<tr class="odd">
<td>1024 to 1099</td>
<td>RealVNC</td>
</tr>
<tr class="even">
<td>1100 to 1105</td>
<td>Apple Inc.</td>
</tr>
<tr class="odd">
<td>-1 to -22</td>
<td>Tight options</td>
</tr>
<tr class="even">
<td>-33 to -218</td>
<td>Tight options</td>
</tr>
<tr class="odd">
<td>-219 to -222</td>
<td>Historical libVNCServer use</td>
</tr>
<tr class="even">
<td>-225</td>
<td>PointerPos</td>
</tr>
<tr class="odd">
<td>-226 to -238</td>
<td>Tight options</td>
</tr>
<tr class="even">
<td>-241 to -246</td>
<td>Tight options</td>
</tr>
<tr class="odd">
<td>-262 to -272</td>
<td>QEMU</td>
</tr>
<tr class="even">
<td>-273 to -304</td>
<td>VMware</td>
</tr>
<tr class="odd">
<td>-306</td>
<td>popa</td>
</tr>
<tr class="even">
<td>-310</td>
<td>OLIVE Call Control</td>
</tr>
<tr class="odd">
<td>-311</td>
<td>ClientRedirect</td>
</tr>
<tr class="even">
<td>-523 to -528</td>
<td>Car Connectivity</td>
</tr>
<tr class="odd">
<td>0x48323634</td>
<td>VA H.264</td>
</tr>
<tr class="even">
<td>0x574d5600 to 0x574d56ff</td>
<td>VMware</td>
</tr>
<tr class="odd">
<td>0xc0a1e5cf</td>
<td>PluginStreaming</td>
</tr>
<tr class="even">
<td>0xfffe0000</td>
<td>KeyboardLedState</td>
</tr>
<tr class="odd">
<td>0xfffe0001</td>
<td>SupportedMessages</td>
</tr>
<tr class="even">
<td>0xfffe0002</td>
<td>SupportedEncodings</td>
</tr>
<tr class="odd">
<td>0xfffe0003</td>
<td>ServerIdentity</td>
</tr>
<tr class="even">
<td>0xfffe0004 to 0xfffe00ff</td>
<td>libVNSServer</td>
</tr>
<tr class="odd">
<td>0xffff0000</td>
<td>Cache</td>
</tr>
<tr class="even">
<td>0xffff0001</td>
<td>CacheEnable</td>
</tr>
<tr class="odd">
<td>0xffff0002</td>
<td>XOR zlib</td>
</tr>
<tr class="even">
<td>0xffff0003</td>
<td>XORMonoRect zlib</td>
</tr>
<tr class="odd">
<td>0xffff0004</td>
<td>XORMultiColor zlib</td>
</tr>
<tr class="even">
<td>0xffff0005</td>
<td>SolidColor</td>
</tr>
<tr class="odd">
<td>0xffff0006</td>
<td>XOREnable</td>
</tr>
<tr class="even">
<td>0xffff0007</td>
<td>CacheZip</td>
</tr>
<tr class="odd">
<td>0xffff0008</td>
<td>SolMonoZip</td>
</tr>
<tr class="even">
<td>0xffff0009</td>
<td>UltraZip</td>
</tr>
<tr class="odd">
<td>0xffff8000</td>
<td>ServerState</td>
</tr>
<tr class="even">
<td>0xffff8001</td>
<td>EnableKeepAlive</td>
</tr>
<tr class="odd">
<td>0xffff8002</td>
<td>FTProtocolVersion</td>
</tr>
<tr class="even">
<td>0xffff8003</td>
<td>Session</td>
</tr>
</tbody>
</table>
<p>The official, up-to-date list is maintained by IANA<a href="#fn5"
class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>.</p>
<h4 id="raw-encoding">Raw Encoding</h4>
<p>The simplest encoding type is raw pixel data. In this case the data
consists of <em>width</em> * <em>height</em> pixel values (where
<em>width</em> and <em>height</em> are the width and height of the
rectangle). The values simply represent each pixel in left-to-right
scanline order. All RFB clients must be able to cope with pixel data in
this raw encoding, and RFB servers should only produce raw encoding
unless the client specifically asks for some other encoding type.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>width</em> * <em>height</em> * <em>bytesPerPixel</em></td>
<td><code>PIXEL</code> array</td>
<td><em>pixels</em></td>
</tr>
</tbody>
</table>
<h4 id="copyrect-encoding">CopyRect Encoding</h4>
<p>The <em>CopyRect</em> (copy rectangle) encoding is a very simple and
efficient encoding which can be used when the client already has the
same pixel data elsewhere in its framebuffer. The encoding on the wire
simply consists of an X,Y coordinate. This gives a position in the
framebuffer from which the client can copy the rectangle of pixel data.
This can be used in a variety of situations, the most obvious of which
are when the user moves a window across the screen, and when the
contents of a window are scrolled. A less obvious use is for optimising
drawing of text or other repeating patterns. An intelligent server may
be able to send a pattern explicitly only once, and knowing the previous
position of the pattern in the framebuffer, send subsequent occurrences
of the same pattern using the <em>CopyRect</em> encoding.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>src-x-position</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>src-y-position</em></td>
</tr>
</tbody>
</table>
<h4 id="rre-encoding">RRE Encoding</h4>
<p>RRE stands for <em>rise-and-run-length encoding</em> and as its name
implies, it is essentially a two-dimensional analogue of run-length
encoding. RRE-encoded rectangles arrive at the client in a form which
can be rendered immediately and efficiently by the simplest of graphics
engines. RRE is not appropriate for complex desktops, but can be useful
in some situations.</p>
<p>The basic idea behind RRE is the partitioning of a rectangle of pixel
data into rectangular subregions (subrectangles) each of which consists
of pixels of a single value and the union of which comprises the
original rectangular region. The near-optimal partition of a given
rectangle into such subrectangles is relatively easy to compute.</p>
<p>The encoding consists of a background pixel value, <em>Vb</em>
(typically the most prevalent pixel value in the rectangle) and a count
<em>N</em>, followed by a list of <em>N</em> subrectangles, each of
which consists of a tuple &lt;<em>v</em>, <em>x</em>, <em>y</em>,
<em>w</em>, <em>h</em>&gt; where <em>v</em> (!= <em>Vb</em>) is the
pixel value, (<em>x</em>, <em>y</em>) are the coordinates of the
subrectangle relative to the top-left corner of the rectangle, and
(<em>w</em>, <em>h</em>) are the width and height of the subrectangle.
The client can render the original rectangle by drawing a filled
rectangle of the background pixel value and then drawing a filled
rectangle corresponding to each subrectangle.</p>
<p>On the wire, the data begins with the header:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>number-of-subrectangles</em></td>
</tr>
<tr class="even">
<td><em>bytesPerPixel</em></td>
<td><code>PIXEL</code></td>
<td><em>background-pixel-value</em></td>
</tr>
</tbody>
</table>
<p>This is followed by <em>number-of-subrectangles</em> instances of the
following structure:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>bytesPerPixel</em></td>
<td><code>PIXEL</code></td>
<td><em>subrect-pixel-value</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>x-position</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>y-position</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>width</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>height</em></td>
</tr>
</tbody>
</table>
<h4 id="corre-encoding">CoRRE Encoding</h4>
<p>CoRRE stands for <em>compressed rise-and-run-length encoding</em> and
as its name implies, it is a variant of the above <a
href="#rre-encoding">RRE Encoding</a> and as such essentially a
two-dimensional analogue of run-length encoding.</p>
<p>The only difference between CoRRE and RRE is that the position, width
and height of the subrectangles are limited to a maximum of 255 pixels.
Because of this, the server needs to produce several rectangles in order
to cover a larger area. The <a href="#hextile-encoding">Hextile
Encoding</a> is probably a better choice in the majority of cases.</p>
<p>On the wire, the data begins with the header:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>number-of-subrectangles</em></td>
</tr>
<tr class="even">
<td><em>bytesPerPixel</em></td>
<td><code>PIXEL</code></td>
<td><em>background-pixel-value</em></td>
</tr>
</tbody>
</table>
<p>This is followed by <em>number-of-subrectangles</em> instances of the
following structure:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>bytesPerPixel</em></td>
<td><code>PIXEL</code></td>
<td><em>subrect-pixel-value</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>x-position</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>y-position</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>width</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>height</em></td>
</tr>
</tbody>
</table>
<h4 id="hextile-encoding">Hextile Encoding</h4>
<p>Hextile is a variation on the RRE idea. Rectangles are split up into
16x16 tiles, allowing the dimensions of the subrectangles to be
specified in 4 bits each, 16 bits in total. The rectangle is split into
tiles starting at the top left going in left-to-right, top-to-bottom
order. The encoded contents of the tiles simply follow one another in
the predetermined order. If the width of the whole rectangle is not an
exact multiple of 16 then the width of the last tile in each row will be
correspondingly smaller. Similarly if the height of the whole rectangle
is not an exact multiple of 16 then the height of each tile in the final
row will also be smaller.</p>
<p>Each tile is either encoded as raw pixel data, or as a variation on
RRE. Each tile has a background pixel value, as before. The background
pixel value does not need to be explicitly specified for a given tile if
it is the same as the background of the previous tile. However the
background pixel value may not be carried over if the previous tile was
raw. If all of the subrectangles of a tile have the same pixel value,
this can be specified once as a foreground pixel value for the whole
tile. As with the background, the foreground pixel value can be left
unspecified, meaning it is carried over from the previous tile. The
foreground pixel value may not be carried over if the previous tile was
raw or had the SubrectsColored bit set. It may, however, be carried over
from a previous tile with the AnySubrects bit clear, as long as that
tile itself carried over a valid foreground from its previous tile.</p>
<p>So the data consists of each tile encoded in order. Each tile begins
with a subencoding type byte, which is a mask made up of a number of
bits:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><h5 id="section-1">1</h5></td>
<td><p><code>U8</code></p></td>
<td><p>1 2 4 8 16</p></td>
<td><p><em>subencoding-mask</em>: <strong>Raw</strong>
<strong>BackgroundSpecified</strong>
<strong>ForegroundSpecified</strong> <strong>AnySubrects</strong>
<strong>SubrectsColoured</strong></p></td>
</tr>
</tbody>
</table>
<p>If the <strong>Raw</strong> bit is set then the other bits are
irrelevant; <em>width</em> * <em>height</em> pixel values follow (where
<em>width</em> and <em>height</em> are the width and height of the
tile). Otherwise the other bits in the mask are as follows:</p>
<dl>
<dt><strong>BackgroundSpecified</strong></dt>
<dd>
<p>If set, a pixel value follows which specifies the background colour
for this tile:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>bytesPerPixel</em></td>
<td><code>PIXEL</code></td>
<td><em>background-pixel-value</em></td>
</tr>
</tbody>
</table>
<p>The first non-raw tile in a rectangle must have this bit set. If this
bit isn't set then the background is the same as the last tile.</p>
</dd>
<dt><strong>ForegroundSpecified</strong></dt>
<dd>
<p>If set, a pixel value follows which specifies the foreground colour
to be used for all subrectangles in this tile:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>bytesPerPixel</em></td>
<td><code>PIXEL</code></td>
<td><em>foreground-pixel-value</em></td>
</tr>
</tbody>
</table>
<p>If this bit is set then the <strong>SubrectsColoured</strong> bit
must be zero.</p>
</dd>
<dt><strong>AnySubrects</strong></dt>
<dd>
<p>If set, a single byte follows giving the number of subrectangles
following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>number-of-subrectangles</em></td>
</tr>
</tbody>
</table>
<p>If not set, there are no subrectangles (i.e. the whole tile is just
solid background colour).</p>
</dd>
<dt><strong>SubrectsColoured</strong></dt>
<dd>
<p>If set then each subrectangle is preceded by a pixel value giving the
colour of that subrectangle, so a subrectangle is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>bytesPerPixel</em></td>
<td><code>PIXEL</code></td>
<td><em>subrect-pixel-value</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>x-and-y-position</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>width-and-height</em></td>
</tr>
</tbody>
</table>
<p>If not set, all subrectangles are the same colour, the foreground
colour; if the <strong>ForegroundSpecified</strong> bit wasn't set then
the foreground is the same as the last tile. A subrectangle is:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>x-and-y-position</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>width-and-height</em></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>The position and size of each subrectangle is specified in two bytes,
<em>x-and-y-position</em> and <em>width-and-height</em>. The
most-significant four bits of <em>x-and-y-position</em> specify the X
position, the least-significant specify the Y position. The
most-significant four bits of <em>width-and-height</em> specify the
width minus one, the least-significant specify the height minus one.</p>
<h4 id="zlib-encoding">zlib Encoding</h4>
<p>The zlib encoding uses zlib<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a> to compress rectangles
encoded according to the <a href="#raw-encoding">Raw Encoding</a>. A
single zlib "stream" object is used for a given RFB connection, so that
zlib rectangles must be encoded and decoded strictly in order.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>length</em></td>
</tr>
<tr class="even">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p>The <em>zlibData</em>, when uncompressed, represents a rectangle
according to the <a href="#raw-encoding">Raw Encoding</a>.</p>
<h4 id="tight-encoding">Tight Encoding</h4>
<p>Tight encoding provides efficient compression for pixel data. To
reduce implementation complexity, the width of any Tight-encoded
rectangle cannot exceed 2048 pixels. If a wider rectangle is desired, it
must be split into several rectangles and each one should be encoded
separately.</p>
<p>The first byte of each Tight-encoded rectangle is a
<em>compression-control</em> byte:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>compression-control</em></td>
</tr>
</tbody>
</table>
<p>The least significant four bits of the <em>compression-control</em>
byte inform the client which zlib compression streams should be reset
before decoding the rectangle. Each bit is independent and corresponds
to a separate zlib stream that should be reset:</p>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Reset stream 0</td>
</tr>
<tr class="even">
<td>1</td>
<td>Reset stream 1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Reset stream 2</td>
</tr>
<tr class="even">
<td>3</td>
<td>Reset stream 3</td>
</tr>
</tbody>
</table>
<p>One of three possible compression methods are supported in the Tight
encoding. These are <strong>BasicCompression</strong>,
<strong>FillCompression</strong> and <strong>JpegCompression</strong>.
If the bit 7 (the most significant bit) of the
<em>compression-control</em> byte is 0, then the compression type is
<strong>BasicCompression</strong>. In that case, bits 7-4 (the most
significant four bits) of <em>compression-control</em> should be
interpreted as follows:</p>
<table>
<thead>
<tr class="header">
<th>Bits</th>
<th>Binary value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5-4</td>
<td>00</td>
<td>Use stream 0</td>
</tr>
<tr class="even">
<td></td>
<td>01</td>
<td>Use stream 1</td>
</tr>
<tr class="odd">
<td></td>
<td>10</td>
<td>Use stream 2</td>
</tr>
<tr class="even">
<td></td>
<td>11</td>
<td>Use stream 3</td>
</tr>
<tr class="odd">
<td>6</td>
<td>0</td>
<td>---</td>
</tr>
<tr class="even">
<td></td>
<td>1</td>
<td><em>read-filter-id</em></td>
</tr>
<tr class="odd">
<td>7</td>
<td>0</td>
<td><strong>BasicCompression</strong></td>
</tr>
</tbody>
</table>
<p>Otherwise, if the bit 7 of <em>compression-control</em> is set to 1,
then the compression method is either <strong>FillCompression</strong>
or <strong>JpegCompression</strong>, depending on other bits of the same
byte:</p>
<table>
<thead>
<tr class="header">
<th>Bits</th>
<th>Binary value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7-4</td>
<td>1000</td>
<td><strong>FillCompression</strong></td>
</tr>
<tr class="even">
<td></td>
<td>1001</td>
<td><strong>JpegCompression</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>any other</td>
<td>Invalid</td>
</tr>
</tbody>
</table>
<p>Note: <strong>JpegCompression</strong> may only be used when
<em>bits-per-pixel</em> is either 16 or 32 and the client has advertized
a quality level using the <a
href="#jpeg-quality-level-pseudo-encoding">JPEG Quality Level
Pseudo-encoding</a>.</p>
<p>The Tight encoding makes use of a new type <code>TPIXEL</code> (Tight
pixel). This is the same as a <code>PIXEL</code> for the agreed pixel
format, except where <em>true-colour-flag</em> is non-zero,
<em>bits-per-pixel</em> is 32, <em>depth</em> is 24 and all of the bits
making up the red, green and blue intensities are exactly 8 bits wide.
In this case a <code>TPIXEL</code> is only 3 bytes long, where the first
byte is the red component, the second byte is the green component, and
the third byte is the blue component of the pixel color value.</p>
<p>The data following the <em>compression-control</em> byte depends on
the compression method.</p>
<dl>
<dt><strong>FillCompression</strong></dt>
<dd>
<p>If the compression type is <strong>FillCompression</strong>, then the
only pixel value follows, in <code>TPIXEL</code> format. This value
applies to all pixels of the rectangle.</p>
</dd>
<dt><strong>JpegCompression</strong></dt>
<dd>
<p>If the compression type is <strong>JpegCompression</strong>, the
following data stream looks like this:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1-3</td>
<td></td>
<td><em>length</em> in compact representation</td>
</tr>
<tr class="even">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td><em>jpeg-data</em></td>
</tr>
</tbody>
</table>
<p><em>length</em> is compactly represented in one, two or three bytes,
according to the following scheme:</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0xxxxxxx</td>
<td>for values 0..127</td>
</tr>
<tr class="even">
<td>1xxxxxxx 0yyyyyyy</td>
<td>for values 128..16383</td>
</tr>
<tr class="odd">
<td>1xxxxxxx 1yyyyyyy zzzzzzzz</td>
<td>for values 16384..4194303</td>
</tr>
</tbody>
</table>
<p>Here each character denotes one bit, xxxxxxx are the least
significant 7 bits of the value (bits 0-6), yyyyyyy are bits 7-13, and
zzzzzzzz are the most significant 8 bits (bits 14-21). For example,
decimal value 10000 should be represented as two bytes: binary 10010000
01001110, or hexadecimal 90 4E.</p>
<p>The <em>jpeg-data</em> is a JFIF stream.</p>
</dd>
<dt><strong>BasicCompression</strong></dt>
<dd>
<p>If the compression type is <strong>BasicCompression</strong> and bit
6 (the <em>read-filter-id</em> bit) of the <em>compression-control</em>
byte was set to 1, then the next (second) byte specifies
<em>filter-id</em> which tells the decoder what filter type was used by
the encoder to pre-process pixel data before the compression. The
<em>filter-id</em> byte can be one of the following:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><h5 id="section-2">1</h5></td>
<td><p><code>U8</code></p></td>
<td><p>0 1 2</p></td>
<td><p><em>filter-id</em> <strong>CopyFilter</strong> (no filter)
<strong>PaletteFilter</strong> <strong>GradientFilter</strong></p></td>
</tr>
</tbody>
</table>
<p>If bit 6 of the <em>compression-control</em> byte is set to 0 (no
<em>filter-id</em> byte), then the <strong>CopyFilter</strong> is
used.</p>
<dl>
<dt><strong>CopyFilter</strong></dt>
<dd>
<p>When the <strong>CopyFilter</strong> is active, raw pixel values in
<code>TPIXEL</code> format will be compressed. See below for details on
the compression.</p>
</dd>
<dt><strong>PaletteFilter</strong></dt>
<dd>
<p>The <strong>PaletteFilter</strong> converts true-color pixel data to
indexed colors and a palette which can consist of 2..256 colors. If the
number of colors is 2, then each pixel is encoded in 1 bit, otherwise 8
bits are used to encode one pixel. 1-bit encoding is performed such way
that the most significant bits correspond to the leftmost pixels, and
each row of pixels is aligned to the byte boundary. When the
<strong>PaletteFilter</strong> is used, the palette is sent before the
pixel data. The palette begins with an unsigned byte which value is the
number of colors in the palette minus 1 (i.e. 1 means 2 colors, 255
means 256 colors in the palette). Then follows the palette itself which
consist of pixel values in <code>TPIXEL</code> format.</p>
</dd>
<dt><strong>GradientFilter</strong></dt>
<dd>
<p>The <strong>GradientFilter</strong> pre-processes pixel data with a
simple algorithm which converts each color component to a difference
between a "predicted" intensity and the actual intensity. Such a
technique does not affect uncompressed data size, but helps to compress
photo-like images better. Pseudo-code for converting intensities to
differences follows:</p>
<pre><code>P[i,j] := V[i-1,j] + V[i,j-1] - V[i-1,j-1];
if (P[i,j] &lt; 0) then P[i,j] := 0;
if (P[i,j] &gt; MAX) then P[i,j] := MAX;
D[i,j] := V[i,j] - P[i,j];</code></pre>
<p>Here <code>V[i,j]</code> is the intensity of a color component for a
pixel at coordinates <code>(i,j)</code>. For pixels outside the current
rectangle, <code>V[i,j]</code> is assumed to be zero (which is relevant
for <code>P[i,0]</code> and <code>P[0,j]</code>). MAX is the maximum
intensity value for a color component.</p>
<p>Note: The <strong>GradientFilter</strong> may only be used when
<em>bits-per-pixel</em> is either 16 or 32.</p>
</dd>
</dl>
<p>After the pixel data has been filtered with one of the above three
filters, it is compressed using the zlib library. But if the data size
after applying the filter but before the compression is less then 12,
then the data is sent as is, uncompressed. Four separate zlib streams
(0..3) can be used and the decoder should read the actual stream id from
the <em>compression-control</em> byte (see <a href="#NOTE1"
class="citation">[NOTE1]</a>).</p>
<p>If the compression is not used, then the pixel data is sent as is,
otherwise the data stream looks like this:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1-3</td>
<td></td>
<td><em>length</em> in compact representation</td>
</tr>
<tr class="even">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p><em>length</em> is compactly represented in one, two or three bytes,
just like in the <strong>JpegCompression</strong> method (see
above).</p>
</dd>
</dl>
<h4 id="zlibhex-encoding">zlibhex Encoding</h4>
<p>The zlibhex encoding uses zlib<a href="#fn7" class="footnote-ref"
id="fnref7" role="doc-noteref"><sup>7</sup></a> to optionally compress
subrectangles according to the <a href="#hextile-encoding">Hextile
Encoding</a>. Refer to the hextile encoding for information on how the
rectangle is divided into subrectangles and other basic properties of
subrectangles. One zlib "stream" object is used for subrectangles
encoded according to the <strong>Raw</strong> subencoding and one zlib
"stream" object is used for all other subrectangles.</p>
<p>The hextile subencoding bitfield is extended with these bits:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><h5 id="section-3">1</h5></td>
<td><p><code>U8</code></p></td>
<td><p>32 64</p></td>
<td><p><em>subencoding-mask</em>: <strong>ZlibRaw</strong>
<strong>Zlib</strong></p></td>
</tr>
</tbody>
</table>
<p>If either of the <strong>ZlibRaw</strong> or the
<strong>Zlib</strong> bit is set, the subrectangle is compressed using
zlib, like this:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>length</em></td>
</tr>
<tr class="even">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p>Like the <strong>Raw</strong> bit in hextile, the
<strong>ZlibRaw</strong> bit in zlibhex cancels all other bits and the
subrectangle is encoded using the first zlib "stream" object. The
<em>zlibData</em>, when uncompressed, should in this case be interpreted
as the <strong>Raw</strong> data in the hextile encoding.</p>
<p>If the <strong>Zlib</strong> bit is set, the rectangle is encoded
using the second zlib "stream" object. The <em>zlibData</em>, when
uncompressed, represents a plain hextile rectangle according to the
lower 5 bits in the subencoding.</p>
<p>If neither the <strong>ZlibRaw</strong> nor the <strong>Zlib</strong>
bit is set, the subrectangle follows the rules described in the <a
href="#hextile-encoding">Hextile Encoding</a>.</p>
<h4 id="zrle-encoding">ZRLE Encoding</h4>
<p>ZRLE stands for Zlib<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a> Run-Length Encoding, and combines
zlib compression, tiling, palettisation and run-length encoding. On the
wire, the rectangle begins with a 4-byte length field, and is followed
by that many bytes of zlib-compressed data. A single zlib "stream"
object is used for a given RFB protocol connection, so that ZRLE
rectangles must be encoded and decoded strictly in order.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>length</em></td>
</tr>
<tr class="even">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td><em>zlibData</em></td>
</tr>
</tbody>
</table>
<p>The <em>zlibData</em> when uncompressed represents tiles of 64x64
pixels in left-to-right, top-to-bottom order, similar to hextile. If the
width of the rectangle is not an exact multiple of 64 then the width of
the last tile in each row is smaller, and if the height of the rectangle
is not an exact multiple of 64 then the height of each tile in the final
row is smaller.</p>
<p>ZRLE makes use of a new type <code>CPIXEL</code> (compressed pixel).
This is the same as a <code>PIXEL</code> for the agreed pixel format,
except where <em>true-colour-flag</em> is non-zero,
<em>bits-per-pixel</em> is 32, <em>depth</em> is 24 or less and all of
the bits making up the red, green and blue intensities fit in either the
least significant 3 bytes or the most significant 3 bytes. In this case
a <code>CPIXEL</code> is only 3 bytes long, and contains the least
significant or the most significant 3 bytes as appropriate.
<em>bytesPerCPixel</em> is the number of bytes in a
<code>CPIXEL</code>.</p>
<p>Note that for the corner case where <em>bits-per-pixel</em> is 32 and
<em>depth</em> is 16 or less (this is a corner case, since the client is
<strong>much</strong> better off using 16 or even 8
<em>bits-per-pixels</em>) a <code>CPIXEL</code> is still 3 bytes long.
By convention, the three least significant bytes are used when both the
three least and the three most significant bytes would cover the used
bits.</p>
<p>Each tile begins with a <em>subencoding</em> type byte. The top bit
of this byte is set if the tile has been run-length encoded, clear
otherwise. The bottom seven bits indicate the size of the palette used:
zero means no palette, one means that the tile is of a single colour, 2
to 127 indicate a palette of that size. The possible values of
<em>subencoding</em> are:</p>
<dl>
<dt>0</dt>
<dd>
<p>Raw pixel data. <em>width</em> * <em>height</em> pixel values follow
(where width and height are the width and height of the tile):</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>width</em> * <em>height</em> * <em>bytesPerCPixel</em></td>
<td><code>CPIXEL</code> array</td>
<td><em>pixels</em></td>
</tr>
</tbody>
</table>
</dd>
<dt>1</dt>
<dd>
<p>A solid tile consisting of a single colour. The pixel value
follows:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>bytesPerCPixel</em></td>
<td><code>CPIXEL</code></td>
<td><em>pixelValue</em></td>
</tr>
</tbody>
</table>
</dd>
<dt>2 to 16</dt>
<dd>
<p>Packed palette types. Followed by the palette, consisting of
<em>paletteSize</em> (=*subencoding*) pixel values. Then the packed
pixels follow, each pixel represented as a bit field yielding an index
into the palette (0 meaning the first palette entry). For
<em>paletteSize</em> 2, a 1-bit field is used, for <em>paletteSize</em>
3 or 4 a 2-bit field is used and for <em>paletteSize</em> from 5 to 16 a
4-bit field is used. The bit fields are packed into bytes, the most
significant bits representing the leftmost pixel (i.e. big endian). For
tiles not a multiple of 8, 4 or 2 pixels wide (as appropriate), padding
bits are used to align each row to an exact number of bytes.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>paletteSize</em> * <em>bytesPerCPixel</em></td>
<td><code>CPIXEL</code> array</td>
<td><em>palette</em></td>
</tr>
<tr class="even">
<td><em>m</em></td>
<td><code>U8</code> array</td>
<td><em>packedPixels</em></td>
</tr>
</tbody>
</table>
<p>where <em>m</em> is the number of bytes representing the packed
pixels. For <em>paletteSize</em> of 2 this is floor((<em>width</em> + 7)
/ 8) * <em>height</em>, for <em>paletteSize</em> of 3 or 4 this is
floor((<em>width</em> + 3) / 4) * <em>height</em>, for
<em>paletteSize</em> of 5 to 16 this is floor((<em>width</em> + 1) / 2)
* <em>height</em>.</p>
</dd>
<dt>17 to 127</dt>
<dd>
<p>Unused (no advantage over palette RLE).</p>
</dd>
<dt>128</dt>
<dd>
<p>Plain RLE. Consists of a number of runs, repeated until the tile is
done. Runs may continue from the end of one row to the beginning of the
next. Each run is a represented by a single pixel value followed by the
length of the run. The length is represented as one or more bytes. The
length is calculated as one more than the sum of all the bytes
representing the length. Any byte value other than 255 indicates the
final byte. So for example length 1 is represented as [0], 255 as [254],
256 as [255,0], 257 as [255,1], 510 as [255,254], 511 as [255,255,0] and
so on.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><em>bytesPerCPixel</em> <em>r</em> 1</p></td>
<td><p><code>CPIXEL</code> <code>U8</code> array
<code>U8</code></p></td>
<td><p>255</p></td>
<td><p><em>pixelValue</em></p>
<p>(<em>runLength</em> - 1) % 255</p></td>
</tr>
</tbody>
</table>
<p>Where <em>r</em> is floor((<em>runLength</em> - 1) / 255).</p>
</dd>
<dt>129</dt>
<dd>
<p>Unused.</p>
</dd>
<dt>130 to 255</dt>
<dd>
<p>Palette RLE. Followed by the palette, consisting of
<em>paletteSize</em> = (<em>subencoding</em> - 128) pixel values:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>paletteSize</em> * <em>bytesPerCPixel</em></td>
<td><code>CPIXEL</code> array</td>
<td><em>palette</em></td>
</tr>
</tbody>
</table>
<p>Then as with plain RLE, consists of a number of runs, repeated until
the tile is done. A run of length one is represented simply by a palette
index:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>paletteIndex</em></td>
</tr>
</tbody>
</table>
<p>A run of length more than one is represented by a palette index with
the top bit set, followed by the length of the run as for plain RLE.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 <em>r</em> 1</p></td>
<td><p><code>U8</code> <code>U8</code> array <code>U8</code></p></td>
<td><p>255</p></td>
<td><p><em>paletteIndex</em> + 128</p>
<p>(<em>runLength</em> - 1) % 255</p></td>
</tr>
</tbody>
</table>
<p>Where <em>r</em> is floor((<em>runLength</em> - 1) / 255).</p>
</dd>
</dl>
<h4 id="jpeg-encoding">JPEG Encoding</h4>
<p>The JPEG encoding uses JPEG format to compress rects. The message is
simply a JPEG image:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>variable</td>
<td><code>U8</code> array</td>
<td><em>data</em></td>
</tr>
</tbody>
</table>
<p>As defined in the JPEG standard, a JPEG image consists of a sequence
of segments, each of which begins with a marker. The EOF marker
indicates the end of the message. When the segments of "Define Huffman
Tables (DHT)" or "Define Quantization Tables (DQT)" do not exist, the
client should reuse the previous Huffman tables or quantization tables
for decoding.</p>
<h4 id="open-h.264-encoding">Open H.264 Encoding</h4>
<p>The Open H.264 Encoding implements the widely used H.264 format for
efficient rectangle compression for transmission over poor communication
channels.</p>
<p>The message looks like this:</p>
<blockquote>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>length</em> of <em>data</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U32</code></td>
<td><em>flags</em></td>
</tr>
<tr class="odd">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td><em>data</em></td>
</tr>
</tbody>
</table>
</blockquote>
<p>The <em>flags</em> is used by the server to send additional
information to the client. The current values of the <em>flags</em> are
listed below. Unknown flag values should be ignored by the client.</p>
<blockquote>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><strong>ResetContext</strong></td>
</tr>
<tr class="even">
<td>1</td>
<td><strong>ResetAllContexts</strong></td>
</tr>
<tr class="odd">
<td>2-31</td>
<td>Currently unused</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The <em>data</em> is one or more H.264 frames glued together in a
row. This encoding prescribes the use of the H.264 baseline profile for
the lowest latency.</p>
<p>Since H.264 is a differential format, this introduces the concept of
context for RFB frame. The context is the state of the H.264
encoder/decoder associated with a particular rectangle. When the server
wants to send an H.264 rectangle, the <em>rect</em> coordinates and size
inside a <em>FrameBufferUpdate</em> will be used to find the decoder
context in the client. If the client finds a suitable decoder that can
be used for the specified coordinates, the client uses it (and its
internal state) to decode and display the new frame. The client should
only decode frames based on the internal state of the context and ignore
changes in the output buffer that may occur when overlapping of rects.
When new data is received, the client context will redraw its rectangle
and update the previously overlapped data.</p>
<p>The server can use the <em>flags</em> to control the contexts of the
client. All currently existing flags must be applied before decoding.
The <strong>ResetContext</strong> flag requires the client to delete the
current context with coordinates specified in <em>FrameBufferUpdate</em>
and create a new one. The <strong>ResetAllContexts</strong> flag deletes
all client contexts.</p>
<p>The server can send an empty <em>data</em> and <em>length</em> equal
to zero, in which case the client must interpret this
<em>FramebufferUpdate</em> as a control message and apply the
<em>flags</em>.</p>
<p>The server can send multiple frames in a single <em>data</em>, which
must be parsed as a regular H.264 stream. The server is unable to split
frames into multiple packets. The <em>data</em> field must always
contain 0 or more whole frames. The client must first decode all the
received frames in a single message, and then display the result.</p>
<p>The server must start sending <em>data</em> for the new context from
I-frame to provide correct decoding for the client side.</p>
<p>The client can handle decoding errors at its discretion. However, the
recommended processing method is to ignore and wait for the correct
frame from the server side.</p>
<p>The client must support 64 simultaneously contexts. The server must
use a minimum number of contexts to ensure that a single screen works.
Ideally, one context per screen. When trying to create a new context
beyond 64, the client must destroy the oldest context, then create the
new one. The oldest context is the one that has not received frame
updates for the longest time.</p>
<h4 id="tight-png-encoding">Tight PNG Encoding</h4>
<p>The Tight PNG encoding is a variant of the Tight encoding that
disallows the <strong>BasicCompression</strong> type and replaces it
with a new <strong>PngCompression</strong> type. The purpose of this
encoding is to support clients which have efficient PNG
decoding/rendering (perhaps even in hardware) but may have inefficient
decoding of the raw zlib data contained in the
<strong>BasicCompression</strong> type.</p>
<p>The Tight PNG encoding is identical to the Tight encoding except that
bit 7-4 of the <em>compression-control</em> byte indicate either
<strong>FillCompression</strong>, <strong>JpegCompression</strong>, or
<strong>PngCompression</strong> and are interpreted as follows:</p>
<table>
<thead>
<tr class="header">
<th>Bits</th>
<th>Binary value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7-4</td>
<td>1000</td>
<td><strong>FillCompression</strong></td>
</tr>
<tr class="even">
<td></td>
<td>1001</td>
<td><strong>JpegCompression</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>1010</td>
<td><strong>PngCompression</strong></td>
</tr>
<tr class="even">
<td></td>
<td>any other</td>
<td>Invalid</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>FillCompression</strong></dt>
<dd>
<p>Identical to Tight encoding.</p>
</dd>
<dt><strong>JpegCompression</strong></dt>
<dd>
<p>Identical to Tight encoding. As with the Tight encoding,
<strong>JpegCompression</strong> may only be used when
<em>bits-per-pixel</em> is either 16 or 32 and the client has advertized
a quality level using the <a
href="#jpeg-quality-level-pseudo-encoding">JPEG Quality Level
Pseudo-encoding</a></p>
</dd>
<dt><strong>PngCompression</strong></dt>
<dd>
<p>If the compression type is <strong>PngCompression</strong>, the data
stream is the same as <strong>JpegCompression</strong> (as defined in
the Tight encoding) except that the <em>jpeg-data</em> is replaced by
<em>png-data</em> which is image data in the PNG (Portable Network
Graphics) format.</p>
</dd>
</dl>
<h3 id="pseudo-encodings">Pseudo-encodings</h3>
<h4 id="jpeg-quality-level-pseudo-encoding">JPEG Quality Level
Pseudo-encoding</h4>
<p>Specifies the desired quality from the JPEG encoder. Encoding number
-23 implies high JPEG quality and -32 implies low JPEG quality. Low
quality can be useful in low bandwidth situations. If the JPEG quality
level is not specified, <strong>JpegCompression</strong> is not used in
the <a href="#tight-encoding">Tight Encoding</a>.</p>
<p>The quality level concerns lossy compression and hence the setting is
a tradeoff between image quality and bandwidth. The specification
defines neither what bandwidth is required at a certain quality level
nor what image quality you can expect. The quality level is also just a
hint to the server.</p>
<h4 id="cursor-pseudo-encoding">Cursor Pseudo-encoding</h4>
<p>A client which requests the <em>Cursor</em> pseudo-encoding is
declaring that it is capable of drawing a mouse cursor locally. This can
significantly improve perceived performance over slow links. The server
sets the cursor shape by sending a pseudo-rectangle with the
<em>Cursor</em> pseudo-encoding as part of an update. The
pseudo-rectangle's <em>x-position</em> and <em>y-position</em> indicate
the hotspot of the cursor, and <em>width</em> and <em>height</em>
indicate the width and height of the cursor in pixels. The data consists
of <em>width</em> * <em>height</em> pixel values followed by a bitmask.
The bitmask consists of left-to-right, top-to-bottom scanlines, where
each scanline is padded to a whole number of bytes floor((<em>width</em>
+ 7) / 8). Within each byte the most significant bit represents the
leftmost pixel, with a 1-bit meaning the corresponding pixel in the
cursor is valid.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>width</em> * <em>height</em> * <em>bytesPerPixel</em></td>
<td><code>PIXEL</code> array</td>
<td><em>cursor-pixels</em></td>
</tr>
<tr class="even">
<td>floor((<em>width</em> + 7) / 8) * <em>height</em></td>
<td><code>U8</code> array</td>
<td><em>bitmask</em></td>
</tr>
</tbody>
</table>
<h4 id="x-cursor-pseudo-encoding">X Cursor Pseudo-encoding</h4>
<p>A client which requests the <em>X Cursor</em> pseudo-encoding is
declaring that it is capable of drawing a mouse cursor locally. This can
significantly improve perceived performance over slow links. The server
sets the cursor shape by sending a pseudo-rectangle with the <em>X
Cursor</em> pseudo-encoding as part of an update.</p>
<p>The pseudo-rectangle's <em>x-position</em> and <em>y-position</em>
indicate the hotspot of the cursor, and <em>width</em> and
<em>height</em> indicate the width and height of the cursor in
pixels.</p>
<p>If either <em>width</em> or <em>height</em> is zero then there is no
data associated with the pseudo-rectangle. Otherwise the data consists
of the primary and secondary colours for the cursor, followed by one
bitmap for the colour and one bitmask for the transparency. The bitmap
and bitmask both consist of left-to-right, top-to-bottom scanlines,
where each scanline is padded to a whole number of bytes
floor((<em>width</em> + 7) / 8). Within each byte the most significant
bit represents the leftmost pixel, with a 1-bit meaning the
corresponding pixel should use the primary colour, or that the pixel is
valid.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>primary-r</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>primary-g</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>primary-b</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>secondary-r</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>secondary-g</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>secondary-b</em></td>
</tr>
<tr class="odd">
<td>floor((<em>width</em> + 7) / 8) * <em>height</em></td>
<td><code>U8</code> array</td>
<td><em>bitmap</em></td>
</tr>
<tr class="even">
<td>floor((<em>width</em> + 7) / 8) * <em>height</em></td>
<td><code>U8</code> array</td>
<td><em>bitmask</em></td>
</tr>
</tbody>
</table>
<h4 id="desktopsize-pseudo-encoding">DesktopSize Pseudo-encoding</h4>
<p>A client which requests the <em>DesktopSize</em> pseudo-encoding is
declaring that it is capable of coping with a change in the framebuffer
width and/or height.</p>
<p>The server changes the desktop size by sending a pseudo-rectangle
with the <em>DesktopSize</em> pseudo-encoding. The pseudo-rectangle's
<em>x-position</em> and <em>y-position</em> are ignored, and
<em>width</em> and <em>height</em> indicate the new width and height of
the framebuffer. There is no further data associated with the
pseudo-rectangle.</p>
<p>The semantics of the <em>DesktopSize</em> pseudo-encoding were
originally not clearly defined and as a results there are multiple
differing implementations in the wild. Both the client and server need
to take special steps to ensure maximum compatibility.</p>
<p>In the initial implementation the <em>DesktopSize</em>
pseudo-rectangle was sent in its own update without any modifications to
the framebuffer data. The client would discard the framebuffer contents
upon receiving this pseudo-rectangle and the server would consider the
entire framebuffer to be modified.</p>
<p>A later implementation sent the <em>DesktopSize</em> pseudo-rectangle
together with modifications to the framebuffer data. It also expected
the client to retain the framebuffer contents as those modifications
could be from after the framebuffer resize had occurred on the
server.</p>
<p>The semantics defined here retain compatibility with both of two
older implementations.</p>
<h6 id="server-semantics">Server Semantics</h6>
<p>The update containing the pseudo-rectangle should not contain any
rectangles that change the framebuffer data as that will most likely be
discarded by the client and will have to be resent later.</p>
<p>The server should assume that the client discards the framebuffer
data when receiving a <em>DesktopSize</em> pseudo-rectangle. It should
therefore not use any encoding that relies on the previous contents of
the framebuffer. The server should also consider the entire framebuffer
to be modified.</p>
<p>Some early client implementations require the <em>DesktopSize</em>
pseudo-rectangle to be the very last rectangle in an update. Servers
should make every effort to support these.</p>
<p>The server should only send a <em>DesktopSize</em> pseudo-rectangle
when an actual change of the framebuffer dimensions has occurred. Some
clients respond to a <em>DesktopSize</em> pseudo-rectangle in a way that
could send the system into an infinite loop if the server sent out the
pseudo-rectangle for anything other than an actual change.</p>
<h6 id="client-semantics">Client Semantics</h6>
<p>The client should assume that the server expects the framebuffer data
to be retained when the framebuffer dimensions change. This requirement
can be satisfied either by actually retaining the framebuffer data, or
by making sure that <em>incremental</em> is set to zero (false) in the
next <em>FramebufferUpdateRequest</em>.</p>
<p>The principle of one framebuffer update being a transition from one
valid state to another does not hold for updates with the
<em>DesktopSize</em> pseudo-rectangle as the framebuffer contents can
temporarily be partially or completely undefined. Clients should try to
handle this gracefully, e.g. by showing a black framebuffer or delay the
screen update until a proper update of the framebuffer contents has been
received.</p>
<h4 id="lastrect-pseudo-encoding">LastRect Pseudo-encoding</h4>
<p>A client which requests the <em>LastRect</em> pseudo-encoding is
declaring that it does not need the exact number of rectangles in a
<em>FramebufferUpdate</em> message. Instead, it will stop parsing when
it reaches a <em>LastRect</em> rectangle. A server may thus start
transmitting the <em>FramebufferUpdate</em> message before it knows
exactly how many rectangles it is going to transmit, and the server
typically advertises this situation by saying that it is going to send
65535 rectangles, but it then stops with a <em>LastRect</em> instead of
sending all of them. There is no further data associated with the
pseudo-rectangle.</p>
<h4 id="compression-level-pseudo-encoding">Compression Level
Pseudo-encoding</h4>
<p>Specifies the desired compression level. Encoding number -247 implies
high compression level, -256 implies low compression level. Low
compression level can be useful to get low latency in medium to high
bandwidth situations and high compression level can be useful in low
bandwidth situations.</p>
<p>The compression level concerns the general tradeoff between CPU time
and bandwidth. It is therefore probably difficult to define exact
cut-off points for which compression levels should be used for any given
bandwidth. The compression level is just a hint for the server, and
there is no specification for what a specific compression level
means.</p>
<p>Most servers use this hint to control lossless compression algorithms
as the tradeoff between CPU time and bandwidth is obvious there. However
it can also be used for other algorithms where this tradeoff is
relevant.</p>
<h4 id="qemu-pointer-motion-change-pseudo-encoding">QEMU Pointer Motion
Change Pseudo-encoding</h4>
<p>A client that supports this encoding declares that is able to send
pointer motion events either as absolute coordinates, or relative
deltas. The server can switch between different pointer motion modes by
sending a rectangle with this encoding. If the <em>x-position</em> in
the update is 1, the server is requesting absolute coordinates, which is
the RFB protocol default when this encoding is not supported. If the
<em>x-position</em> in the update is 0, the server is requesting
relative deltas.</p>
<p>When relative delta mode is active, the semantics of the <a
href="#pointerevent">PointerEvent</a> message are changed. The
<em>x-position</em> and <em>y-position</em> fields are to be treated as
<code>S16</code> quantities, denoting the delta from the last position.
A client can compute the signed deltas with the logic:</p>
<pre><code>uint16 dx = x + 0x7FFF - last_x
uint16 dy = y + 0x7FFF - last_y</code></pre>
<p>If the client needs to send an updated <em>button-mask</em> without
any associated motion, it should use the value 0x7FFF in the
<em>x-position</em> and <em>y-position</em> fields of the <a
href="#pointerevent">PointerEvent</a></p>
<p>Servers are advised to implement this pseudo-encoding if the virtual
desktop is associated a input device that expects relative coordinates,
for example, a virtual machine with a PS/2 mouse. Prior to this
extension, a server with such a input device would have to perform the
absolute to relative delta conversion itself. This can result in the
client pointer hitting an "invisible wall".</p>
<p>Clients are advised that when generating events in relative pointer
mode, they should grab and hide the local pointer. When the local
pointer hits any edge of the client window, it should be warped back by
100 pixels. This ensures that continued movement of the user's input
device will continue to generate relative deltas and thus avoid the
"invisible wall" problem.</p>
<h4 id="qemu-extended-key-event-pseudo-encoding">QEMU Extended Key Event
Pseudo-encoding</h4>
<p>A client that supports this encoding is indicating that it is able to
provide raw keycodes as an alternative to keysyms. If a server wishes to
receive raw keycodes it will send an empty pseudo-rectangle with the
matching pseudo-encoding. After receiving this notification, clients may
optionally use the <a href="#qemu-extended-key-event-message">QEMU
Extended Key Event Message</a> to send key events, in preference to the
traditional <a href="#keyevent">KeyEvent</a> message.</p>
<h4 id="qemu-audio-pseudo-encoding">QEMU Audio Pseudo-encoding</h4>
<p>A client that supports this encoding is indicating that it is able to
receive an audio data stream. If a server wishes to send audio data it
will send an empty pseudo-rectangle with the matching pseudo-encoding.
After receiving this notification, clients may optionally use the <a
href="#qemu-audio-client-message">QEMU Audio Client Message</a>.</p>
<h4 id="qemu-led-state-pseudo-encoding">QEMU LED State
Pseudo-encoding</h4>
<p>A client that supports this encoding is indicating that it can toggle
the state of lock keys on the local keyboard. The server will send a
pseudo-rectangle with the following contents when it wishes to update
the client's state:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>state</em></td>
</tr>
</tbody>
</table>
<p>The bits of <em>state</em> are defined as:</p>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Scroll Lock</td>
</tr>
<tr class="even">
<td>1</td>
<td>Num Lock</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Caps Lock</td>
</tr>
</tbody>
</table>
<p>The remaining bits are reserved and must be ignored.</p>
<p>An update must be sent whenever the server state changes, but may
also be sent at other times to compensate for variance in behaviour
between the server and client keyboard handling.</p>
<h4 id="gii-pseudo-encoding">gii Pseudo-encoding</h4>
<p>A client that supports the General Input Interface extension starts
by requesting the <em>gii</em> pseudo-encoding declaring that it is
capable of accepting the <a href="#gii-server-message">gii Server
Message</a>. The server, in turn, declares that it is capable of
accepting the <a href="#gii-client-message">gii Client Message</a> by
sending a <a href="#gii-server-message">gii Server Message</a> of
subtype <em>version</em>.</p>
<p>Requesting the <em>gii</em> pseudo-encoding is the first step when a
client wants to use the <em>gii</em> extension of the RFB protocol. The
<em>gii</em> extension is used to provide a more powerful input protocol
for cases where the standard input model is insufficient. It supports
relative mouse movements, mouses with more than 8 buttons and mouses
with more than three axes. It even supports joysticks and gamepads.</p>
<h4 id="desktopname-pseudo-encoding">DesktopName Pseudo-encoding</h4>
<p>A client which requests the DesktopName pseudo-encoding is declaring
that it is capable of coping with a change of the desktop name. The
server changes the desktop name by sending a pseudo-rectangle with the
DesktopName pseudo-encoding in an update. The pseudo-rectangle's
x-position, y-position, width, and height must be zero. After the
rectangle header, a string with the new name follows.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>name-length</em></td>
</tr>
<tr class="even">
<td><em>name-length</em></td>
<td><code>U8</code> array</td>
<td><em>name-string</em></td>
</tr>
</tbody>
</table>
<p>The text encoding used for <em>name-string</em> is UTF-8.</p>
<h4 id="extendeddesktopsize-pseudo-encoding">ExtendedDesktopSize
Pseudo-encoding</h4>
<p>A client which requests the <em>ExtendedDesktopSize</em>
pseudo-encoding is declaring that it is capable of coping with a change
in the framebuffer width, height, and/or screen configuration. This
encoding is used in conjunction with the <em>SetDesktopSize</em>
message. If a server supports the <em>ExtendedDesktopSize</em> encoding,
it must also have basic support for the <em>SetDesktopSize</em> message
although it may deny all requests to change the screen layout.</p>
<p>The <em>ExtendedDesktopSize</em> pseudo-encoding is designed to
replace the simpler <em>DesktopSize</em> one. Servers and clients should
support both for maximum compatibility, but a server must only send the
extended version to a client asking for both. The semantics of
<em>DesktopSize</em> are not as well-defined as for
<em>ExtendedDesktopSize</em> and handling both at the same time would
require needless complexity in the client.</p>
<p>The server must send an <em>ExtendedDesktopSize</em> rectangle in
response to a <em>FramebufferUpdateRequest</em> with
<em>incremental</em> set to zero, assuming the client has requested the
<em>ExtendedDesktopSize</em> pseudo-encoding using the
<em>SetEncodings</em> message. This requirement is needed so that the
client has a reliable way of fetching the initial screen configuration,
and to determine if the server supports the <em>SetDesktopSize</em>
message.</p>
<p>A consequence of this is that a client must not respond to an
<em>ExtendedDesktopSize</em> rectangle by sending a
<em>FramebufferUpdateRequest</em> with <em>incremental</em> set to zero.
Doing so would make the system go into an infinite loop.</p>
<p>The server must also send an <em>ExtendedDesktopSize</em> rectangle
in response to a <em>SetDesktopSize</em> message, indicating the
result.</p>
<p>For a full description of server behaviour as a result of the
<em>SetDesktopSize</em> message, see <a
href="#setdesktopsize">SetDesktopSize</a>.</p>
<p>Rectangles sent as a result of a <em>SetDesktopSize</em> message must
be sent as soon as possible. Rectangles sent for other reasons may be
subjected to delays imposed by the server.</p>
<p>An update containing an <em>ExtendedDesktopSize</em> rectangle must
not contain any changes to the framebuffer data, neither before nor
after the <em>ExtendedDesktopSize</em> rectangle.</p>
<p>The pseudo-rectangle's <em>x-position</em> indicates the reason for
the change:</p>
<dl>
<dt>0</dt>
<dd>
<p>The screen layout was changed via non-RFB means on the server. For
example the server may have provided means for server-side applications
to manipulate the screen layout. This code is also used when the client
sends a non-incremental <em>FrameBufferUpdateRequest</em> to learn the
server's current state.</p>
</dd>
<dt>1</dt>
<dd>
<p>The client receiving this message requested a change of the screen
layout. The change may or may not have happened depending on server
policy or available resources. The status code in the
<em>y-position</em> field must be used to determine which.</p>
</dd>
<dt>2</dt>
<dd>
<p>Another client requested a change of the screen layout and the server
approved it. A rectangle with this code is never sent if the server
denied the request.</p>
</dd>
</dl>
<p>More reasons may be added in the future. Clients should treat an
unknown value as a server-side change (i.e. as if <em>x-position</em>
was set to zero).</p>
<p>The pseudo-rectangle's <em>y-position</em> indicates the status code
for a change requested by a client:</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>No error</td>
</tr>
<tr class="even">
<td>1</td>
<td>Resize is administratively prohibited</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Out of resources</td>
</tr>
<tr class="even">
<td>3</td>
<td>Invalid screen layout</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Request forwarded (might complete asyncronously)</td>
</tr>
</tbody>
</table>
<p>This field shall be set to zero by the server and ignored by clients
when not defined. Other error codes may be added in the future and
clients must treat them as an unknown failure.</p>
<p>The "Request forwarded" error code is used when the server is not in
direct control of the screen layout and is unable to determine if the
request will succeed or not. An example for this situation is a virtual
machine monitor like qemu which can only forward the request to the
guest, but it is in the hands of the guest to actually respond to the
request. In case the request succeeds the server will send another
<em>ExtendedDesktopSize</em> message. Note that there can be a longer
delay and even continuous screen updates before the request succeeds,
for example in case the request comes in while the guest is booting.</p>
<p>The <em>width</em> and <em>height</em> indicates the new width and
height of the framebuffer.</p>
<p>The encoding data is defined as:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 3</p></td>
<td><p><code>U8</code></p></td>
<td><p><em>number-of-screens</em> <em>padding</em></p></td>
</tr>
<tr class="even">
<td><em>number-of-screens</em> * 16</td>
<td><code>SCREEN</code> array</td>
<td><em>screens</em></td>
</tr>
</tbody>
</table>
<p>The <em>number-of-screens</em> field indicates the number of active
screens and allows for multi head configurations. It also indicates how
many <code>SCREEN</code> structures follow, which define the position
and dimensions of heads within the framebuffer extents. The semantics of
screens are defined in <a href="#screen-model">Screen Model</a>. The
<code>SCREEN</code> structures are defined as:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>id</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>x-position</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>y-position</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>width</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>height</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U32</code></td>
<td><em>flags</em></td>
</tr>
</tbody>
</table>
<p>The <em>id</em> field contains an arbitrary value that the server and
client can use to map RFB screens to physical screens. The value must be
unique in the current set of screens and must be preserved for the
lifetime of that RFB screen. New ids are assigned by whichever side
creates the screen. An <em>id</em> may be reused if there has been a
subsequent update of the screen layout where the <em>id</em> was not
used.</p>
<p>The <em>flags</em> field is currently unused. Clients and servers
must ignore, but preserve, any bits it does not understand. For new
screens, those bits must be set to zero.</p>
<p>Note that a simple client which does not support multi head does not
need to parse the list of screens and can simply display the entire
framebuffer whose extents were given by the <em>width</em> and
<em>height</em> field of the <code>FramebufferUpdate</code> message.</p>
<h4 id="xvp-pseudo-encoding">xvp Pseudo-encoding</h4>
<p>A client which requests the <em>xvp</em> pseudo-encoding is declaring
that it wishes to use the <em>xvp</em> extension. If the server supports
this, it replies with a message of type <a
href="#xvp-server-message">xvp Server Message</a>, using an
<em>xvp-message-code</em> of <em>XVP_INIT</em>. This informs the client
that it may then subsequently send messages of type <a
href="#xvp-client-message">xvp Client Message</a>.</p>
<h4 id="fence-pseudo-encoding">Fence Pseudo-encoding</h4>
<p>A client which requests the <em>Fence</em> pseudo-encoding is
declaring that it supports and/or wishes to use the <em>Fence</em>
extension. The server should send a <a
href="#serverfence">ServerFence</a> the first time it sees a
<code>SetEncodings</code> message with the <em>Fence</em>
pseudo-encoding, in order to inform the client that this extension is
supported. The message can use any flags or payload.</p>
<h4 id="continuousupdates-pseudo-encoding">ContinuousUpdates
Pseudo-encoding</h4>
<p>A client which requests the <em>ContinuousUpdates</em>
pseudo-encoding is declaring that it wishes to use the <a
href="#enablecontinuousupdates">EnableContinuousUpdates</a> extension.
The server must send a <a
href="#endofcontinuousupdates">EndOfContinuousUpdates</a> message the
first time it sees a <code>SetEncodings</code> message with the
<em>ContinuousUpdates</em> pseudo-encoding, in order to inform the
client that the extension is supported.</p>
<h4 id="cursor-with-alpha-pseudo-encoding">Cursor With Alpha
Pseudo-encoding</h4>
<p>A client which requests the <em>Cursor With Alpha</em>
pseudo-encoding is declaring that it is capable of drawing a mouse
cursor locally. This can significantly improve perceived performance
over slow links. The server sets the cursor shape by sending a
pseudo-rectangle with the <em>Cursor With Alpha</em> pseudo-encoding as
part of an update. The pseudo-rectangle's <em>x-position</em> and
<em>y-position</em> indicate the hotspot of the cursor, and
<em>width</em> and <em>height</em> indicate the width and height of the
cursor in pixels. The data consists of the following header:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>S32</code></td>
<td><em>encoding</em></td>
</tr>
</tbody>
</table>
<p>It is followed by <em>width</em> * <em>height</em> pixels values
encoded according to <em>encoding</em>. The pixel format is always 32
bits with 8 bits for each channel in the order red, green, blue, alpha.
Alpha is pre-multiplied for each colour channel.</p>
<p>The server is free to use any encoding that the client has specified
as supported. However some encodings may be unsuitable as they cannot
include the extra bits that are used for alpha. Also note that the data
used for the cursor shares state with other rects. E.g. the zlib stream
for a ZRLE encoding is the same as for data rects.</p>
<h4 id="jpeg-fine-grained-quality-level-pseudo-encoding">JPEG
Fine-Grained Quality Level Pseudo-encoding</h4>
<p>The JPEG Fine-Grained Quality Level pseudo-encoding allows the image
quality to be specified on a 0 to 100 scale, with -512 corresponding to
image quality 0 and -412 corresponding to image quality 100. This
pseudo-encoding was originally intended for use with JPEG-encoded
subrectangles, but it could be used with other types of image encoding
as well.</p>
<h4 id="jpeg-subsampling-level-pseudo-encoding">JPEG Subsampling Level
Pseudo-Encoding</h4>
<p>The JPEG Subsampling Level pseudo-encoding allows the level of
chrominance subsampling to be specified. When a JPEG image is encoded,
the RGB pixels are first converted to YCbCr, a colorspace in which
brightness (luminance) is separated from color (chrominance). Since the
human eye is more sensitive to spatial changes in brightness than to
spatial changes in color, the chrominance components (Cb, Cr) can be
subsampled to save bandwidth without losing much image quality (on
smooth images, such as photographs, chrominance subsampling is often not
distinguishable by the human eye). Subsampling can be implemented either
by averaging together groups of chrominance components or by simply
picking one component from the group and discarding the rest.</p>
<p>The values for this pseudo-encoding are defined as follows:</p>
<dl>
<dt>-768 = 1X chrominance subsampling (no chrominance subsampling).</dt>
<dd>
<p>Chrominance components are sent for every pixel in the source
image.</p>
</dd>
<dt>-767 = 4X chrominance subsampling. Chrominance components are sent
for every</dt>
<dd>
<p>fourth pixel in the source image. This would typically be implemented
using 4:2:0 subsampling (2X subsampling in both X and Y directions), but
it could also be implemented using 4:1:1 subsampling (4X subsampling in
the X direction.)</p>
</dd>
<dt>-766 = 2X chrominance subsampling. Chrominance components are sent
for every</dt>
<dd>
<p>other pixel in the source image. This would typically be implemented
using 4:2:2 subsampling (2X subsampling in the X direction.)</p>
</dd>
<dt>-765 = Grayscale. All chrominance components in the source image
are</dt>
<dd>
<p>discarded.</p>
</dd>
<dt>-764 = 8X chrominance subsampling. Chrominance components are sent
for every</dt>
<dd>
<p>8th pixel in the source image. This would typically be implemented
using 4:1:0 subsampling (4X subsampling in the X direction and 2X
subsampling in the Y direction.)</p>
</dd>
<dt>-763 = 16X chrominance subsampling. Chrominance components are sent
for every</dt>
<dd>
<p>16th pixel in the source image. This would typically be implemented
using 4X subsampling in both X and Y directions.</p>
</dd>
</dl>
<p>This pseudo-encoding was originally intended for use with
JPEG-encoded subrectangles, but it could be used with other types of
image encoding as well.</p>
<h4 id="vmware-cursor-pseudo-encoding">VMware Cursor
Pseudo-encoding</h4>
<p>A server sets the cursor shape by sending a pseudo-rectangle with the
VMware Cursor pseudo-encoding as part of an update. The
pseudo-rectangle's <em>x-position</em> and <em>y-position</em> indicate
the hotspot of the cursor, and <em>width</em> and <em>height</em>
indicate the width and height of the cursor in pixels.</p>
<p>The data starts with a <em>cursor-type</em> byte followed by
padding:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>cursor-type</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td>padding</td>
</tr>
</tbody>
</table>
<p>The value of <em>cursor-type</em> is either 0 to indicate a 'classic'
cursor which consists of an AND mask and a XOR mask, or 1 indicate an
alpha cursor.</p>
<p>The data for a classic cursor consists two sets of <em>width</em> *
<em>height</em> pixel values, defining an AND mask and a XOR mask:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>width</em> * <em>height</em> * <em>bytesPerPixel</em></td>
<td><code>PIXEL</code> array</td>
<td><em>and-mask</em></td>
</tr>
<tr class="even">
<td><em>width</em> * <em>height</em> * <em>bytesPerPixel</em></td>
<td><code>PIXEL</code> array</td>
<td><em>xor-mask</em></td>
</tr>
</tbody>
</table>
<p>Classic cursors can be drawn using the following code:</p>
<pre><code>dst[i] = (dst[i] &amp; and-mask[i]) ^ xor-mask[i];</code></pre>
<p>The data for an alpha cursor consists of <em>width</em> *
<em>height</em> RGBA pixel values:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>width</em> * <em>height</em> * 4</td>
<td><code>U8</code> array</td>
<td><em>cursor bytes</em></td>
</tr>
</tbody>
</table>
<p>Alpha cursors should be drawn by compositing the cursor image into
the framebuffer.</p>
<h4 id="vmware-cursor-state-pseudo-encoding">VMware Cursor State
Pseudo-encoding</h4>
<p>A server sets the cursor state by sending a pseudo-rectangle with the
VMware Cursor State pseudo-encoding as part of an update.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>cursor-state</em></td>
</tr>
</tbody>
</table>
<p><em>cursor-state</em> is a bit-field which describes the state of the
cursor:</p>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Cursor visible.</td>
</tr>
<tr class="even">
<td>1</td>
<td>Cursor absolute.</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Cursor wrap.</td>
</tr>
</tbody>
</table>
<p>If cursor visible is not set, the cursor should not be rendered into
the framebuffer until another cursor state message is received that
turns the cursor back on.</p>
<p>The cursor absolute bit indicates whether the virtual machine is
using an absolute or relative mouse.</p>
<p>The cursor warp bit is set when the virtual machine artificially
moves the position of the cursor. This value is for information purposes
only.</p>
<h4 id="vmware-cursor-position-pseudo-encoding">VMware Cursor Position
Pseudo-encoding</h4>
<p>A server updates the cursor position by sending a pseudo-rectangle
with the VMware Cursor Position pseudo-encoding. The <em>x-position</em>
and <em>y-position</em> define the new position of the cursor hot spot
(not the the top left corner of cursor image).</p>
<h4 id="vmware-key-repeat-pseudo-encoding">VMware Key Repeat
Pseudo-encoding</h4>
<p>The server notifies the client of changes to the keyboard key repeat
by sending a pseudo-rectangle with the VMware Key Repeat
pseudo-encoding. It is used to determine whether the client or server
should handle the key repeat.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>key-repeat-enabled</em></td>
</tr>
<tr class="even">
<td>4</td>
<td><code>U32</code></td>
<td><em>period</em></td>
</tr>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>delay</em></td>
</tr>
</tbody>
</table>
<p><em>key-repeat-enabled</em> is 1 if the VNC client should handle key
repeat, 0 if the server handles key repeat. <em>period</em> defines the
period to wait between key repeats. <em>delay</em> defines the delay for
the first key repeat.</p>
<h4 id="vmware-led-state-pseudo-encoding">VMware LED State
Pseudo-encoding</h4>
<p>The server sends a pseudo-rectangle with the VMware LED State
pseudo-encoding to toggle the state of lock keys on the keyboard.</p>
<p>This pseudo-rectangle has the following contents:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td><em>led-flags</em></td>
</tr>
</tbody>
</table>
<p><em>led-flags</em> is a bitmask which defines whether a keyboard LED
is on or off.</p>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Scroll Lock</td>
</tr>
<tr class="even">
<td>1</td>
<td>Num Lock</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Caps Lock</td>
</tr>
</tbody>
</table>
<p>The remaining bits are reserved and must be ignored.</p>
<h4 id="vmware-display-mode-change-pseudo-encoding">VMware Display Mode
Change Pseudo-encoding</h4>
<p>The server changes the desktop size by sending a pseudo-rectangle
with the VMware Display Mode Change pseudo-encoding.</p>
<p>This encoding is used for scenarios not addressed by the <a
href="#desktopsize-pseudo-encoding">DesktopSize Pseudo-encoding</a>.</p>
<p>Specifically, the <a href="#desktopsize-pseudo-encoding">DesktopSize
Pseudo-encoding</a> does not allow the VNC server to redefine both the
color depth and size of the framebuffer. This is useful when the client
prefers to receive the framebuffer native color depth at all times. It
is defined to be similar to the ServerInitialisation header to
facilitate client implementations.</p>
<p>The new pixel format takes effect immediately after the server sends
a pseudo-rectangle with the VMware Display Mode Change
pseudo-encoding.</p>
<p>The <em>width</em> and <em>height</em> of the pseudo-rectangle
specify the new width and height of the display. The rest of the format
is described below:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>bits-per-sample</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>depth</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>color</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>true-color</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>max-red</em></td>
</tr>
<tr class="even">
<td>2</td>
<td><code>U16</code></td>
<td><em>max-green</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>max-blue</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>U8</code></td>
<td><em>red-shift</em></td>
</tr>
<tr class="odd">
<td>1</td>
<td><code>U8</code></td>
<td><em>green-shift</em></td>
</tr>
<tr class="even">
<td><p>1 3</p></td>
<td><p><code>U8</code></p></td>
<td><p><em>blue-shift</em> padding</p></td>
</tr>
</tbody>
</table>
<h4 id="vmware-virtual-machine-state-pseudo-encoding">VMware Virtual
Machine State Pseudo-encoding</h4>
<p>The server sends a pseudo-rectangle with the VMware Virtual Machine
State pseudo-encoding to notify the client of changes in the Virtual
Machine state.</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td><code>U16</code></td>
<td><em>vm-state-flags</em></td>
</tr>
</tbody>
</table>
<p><em>vm-state-flags</em> is a bitmask field. These flags describe the
virtual machine state.</p>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>A end-user sitting at a local virtual machine console has entered
fullscreen mode.</td>
</tr>
<tr class="even">
<td>1</td>
<td>A end-user sitting at a local virtual machine console has
temporarily disabled VNC updates.</td>
</tr>
</tbody>
</table>
<h4 id="extended-clipboard-pseudo-encoding">Extended Clipboard
Pseudo-Encoding</h4>
<p>A client which requests the <em>Extended Clipboard</em>
pseudo-encoding is declaring that it supports the extended versions of
the <a href="#clientcuttext">ClientCutText</a> and <a
href="#servercuttext">ServerCutText</a> messages.</p>
<p>The format of these messages are altered so that <em>length</em> is
now signed rather than unsigned:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>1 3 4</p></td>
<td><p><code>U8</code></p>
<p><code>S32</code></p></td>
<td><p>6/3</p></td>
<td><p><em>message-type</em> <em>padding</em> <em>length</em></p></td>
</tr>
</tbody>
</table>
<p>A positive value of <em>length</em> indicates that the message
follows the original format with 8859-1 text data:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>length</em></td>
<td><code>U8</code> array</td>
<td></td>
<td><em>text</em></td>
</tr>
</tbody>
</table>
<p>A negative value of <em>length</em> indicates that the extended
message format is used and <em>abs(length)</em> is the total number of
following bytes.</p>
<p>All messages start with a header:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td><code>U32</code></td>
<td></td>
<td><em>flags</em></td>
</tr>
</tbody>
</table>
<p>The bits of <em>flags</em> have the following meaning:</p>
<table>
<thead>
<tr class="header">
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><em>text</em></td>
</tr>
<tr class="even">
<td>1</td>
<td><em>rtf</em></td>
</tr>
<tr class="odd">
<td>2</td>
<td><em>html</em></td>
</tr>
<tr class="even">
<td>3</td>
<td><em>dib</em></td>
</tr>
<tr class="odd">
<td>4</td>
<td><em>files</em></td>
</tr>
<tr class="even">
<td>5-15</td>
<td>Reserved for future formats</td>
</tr>
<tr class="odd">
<td>16-23</td>
<td>Reserved</td>
</tr>
<tr class="even">
<td>24</td>
<td><em>caps</em></td>
</tr>
<tr class="odd">
<td>25</td>
<td><em>request</em></td>
</tr>
<tr class="even">
<td>26</td>
<td><em>peek</em></td>
</tr>
<tr class="odd">
<td>27</td>
<td><em>notify</em></td>
</tr>
<tr class="even">
<td>28</td>
<td><em>provide</em></td>
</tr>
<tr class="odd">
<td>29-31</td>
<td>Reserved for future actions</td>
</tr>
</tbody>
</table>
<p>The different formats are:</p>
<dl>
<dt><em>text</em></dt>
<dd>
<p>Plain, unformatted text using the UTF-8 encoding. End of line is
represented by carriage-return and linefeed / newline pairs (values 13
and 10). The text must be followed by a terminating null even though the
length is also explicitly given.</p>
</dd>
<dt><em>rtf</em></dt>
<dd>
<p>Microsoft Rich Text Format.</p>
</dd>
<dt><em>html</em></dt>
<dd>
<p>Microsoft HTML clipboard fragments.</p>
</dd>
<dt><em>dib</em></dt>
<dd>
<p>Microsoft Device Independent Bitmap v5. A file header must not be
included.</p>
</dd>
<dt><em>files</em></dt>
<dd>
<p>Currently reserved but not defined.</p>
</dd>
</dl>
<p>If <em>caps</em> is set then the other bits indicate which formats
and actions that the sender is willing to receive. Following
<em>flags</em> is an array indicating the maximing unsolicited size for
each format:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>formats</em> * 4</td>
<td><code>U32</code> array</td>
<td></td>
<td><em>sizes</em></td>
</tr>
</tbody>
</table>
<p>The number of entries in <em>sizes</em> corresponds to the number of
format bits set in <em>flags</em> (bit 0-15).</p>
<p>The server must send a <a href="#servercuttext">ServerCutText</a>
message with <em>caps</em> set on each <a
href="#setencodings">SetEncodings</a> message received which includes
the <em>Extended Clipboard</em> pseudo-encoding.</p>
<p>The client may send a <a href="#clientcuttext">ClientCutText</a>
message with <em>caps</em> set back to indicate its capabilities.
Otherwise the client is assumed to support <em>text</em>, <em>rtf</em>,
<em>html</em>, <em>request</em>, <em>notify</em> and <em>provide</em>
and a maximum size of 20 MiB for <em>text</em> and 0 bytes for the other
types.</p>
<p>Note that it is recommended to set all sizes to 0 bytes to force all
clipboard updates to be sent in the form of a <em>notify</em> action.
Failing to do so makes it ambiguous if an incoming message indicates a
completely new set of formats, or an update to previous formats caused
by size restrictions. It may be possible to also resolve this ambiguity
using <em>peek</em> actions.</p>
<p>Also be aware that there are some implementations that deviate from
the behaviour specified here. The prominent changes are that
<em>dib</em> is also in the default set of supported formats, that
default limits are now 10 MiB for <em>text</em>, 2 MiB for <em>rtf</em>
and <em>html</em>, and 0 bytes for <em>dib</em>, and that the client
ignores the advertised formats and maximum sizes given in the
<em>caps</em> message.</p>
<p>If <em>caps</em> is not set then only one of the other actions (bit
24-31) may be set.</p>
<dl>
<dt><em>request</em></dt>
<dd>
<p>The recipient should respond with a <em>provide</em> message with the
clipboard data for the formats indicated in <em>flags</em>. No other
data is provided with this message.</p>
</dd>
<dt><em>peek</em></dt>
<dd>
<p>The recipient should send a new <em>notify</em> message indicating
which formats are available. No other bits in <em>flags</em> need to be
set and no other data is provided with this message.</p>
</dd>
<dt><em>notify</em></dt>
<dd>
<p>This message indicates which formats are available on the remote side
and should be sent whenever the clipboard changes, or as a response to a
<em>peek</em> message. The available formats are specified in
<em>flags</em> and no other data is provided with this message.</p>
</dd>
<dt><em>provide</em></dt>
<dd>
<p>This message includes the actual clipboard data and should be sent
whenever the clipboard changes and the data for each format is less than
the respective specified maximum size, or as a response to a
<em>request</em> message.</p>
<p>The header is followed by a Zlib<a href="#fn9" class="footnote-ref"
id="fnref9" role="doc-noteref"><sup>9</sup></a> stream which contains a
pair of <em>size</em> and <em>data</em> for each format indicated in
<em>caps</em>:</p>
<table>
<thead>
<tr class="header">
<th>No. of bytes</th>
<th>Type</th>
<th>[Value]</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>4 <em>size</em></p></td>
<td><p><code>U32</code> <code>U8</code> array</p></td>
<td></td>
<td><p><em>size</em> <em>data</em></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<div id="citations">
<dl>
<dt><span id="NOTE1" class="citation-label">NOTE1</span></dt>
<dd>
<p>The decoder must reset the zlib streams before decoding the
rectangle, if some of the bits 0, 1, 2 and 3 in the
<em>compression-control</em> byte are set to 1. Note that the decoder
must reset the indicated zlib streams even if the compression type is
<strong>FillCompression</strong> or
<strong>JpegCompression</strong>.</p>
</dd>
</dl>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="http://www.iana.org/assignments/rfb/rfb.xml">http://www.iana.org/assignments/rfb/rfb.xml</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Only valid if the <a href="#tight-security-type">Tight
Security Type</a> is enabled.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a
href="http://www.iana.org/assignments/rfb/rfb.xml">http://www.iana.org/assignments/rfb/rfb.xml</a><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a
href="http://www.iana.org/assignments/rfb/rfb.xml">http://www.iana.org/assignments/rfb/rfb.xml</a><a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a
href="http://www.iana.org/assignments/rfb/rfb.xml">http://www.iana.org/assignments/rfb/rfb.xml</a><a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>see <a
href="http://www.gzip.org/zlib/">http://www.gzip.org/zlib/</a><a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>see <a
href="http://www.gzip.org/zlib/">http://www.gzip.org/zlib/</a><a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>see <a
href="http://www.gzip.org/zlib/">http://www.gzip.org/zlib/</a><a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>see <a
href="http://www.gzip.org/zlib/">http://www.gzip.org/zlib/</a><a
href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
